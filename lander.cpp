/**
 * @file lander.cpp
 * @brief Classic lunar lander game for Windows
 * @author Todd Dube
 * @copyright Copyright (c) 2025 Todd Dube
 *
 * A classic lunar lander game with physics simulation, terrain generation,
 * and multiple difficulty levels. Navigate your lander to safe landing zones
 * while managing fuel and velocity.
 */

// ============================================================================
// Platform Configuration and Unicode Setup
// ============================================================================
#ifndef UNICODE
#define UNICODE
#endif
#ifndef _UNICODE
#define _UNICODE
#endif

// ============================================================================
// System and Library Includes
// ============================================================================
#include <windows.h>
#include <windowsx.h>
#include <strsafe.h>
#include <vector>
#include <cmath>
#include <algorithm>
#include <random>
#include <string>
#include <fstream>
#include <iomanip>

// Include version header (generated by build system)
#ifdef _MSC_VER
#include "version.h"
#else
// Fallback for manual compilation
#define LANDER_VERSION_STRING "1.0.0"
#define LANDER_AUTHOR "Todd Dube"
#define LANDER_COPYRIGHT "Copyright (c) 2025 Todd Dube"
#endif

// ============================================================================
// Game Constants
// ============================================================================
constexpr int WINDOW_WIDTH = 800;
constexpr int WINDOW_HEIGHT = 600;
constexpr float GRAVITY = 0.05f;           // Downward acceleration per frame
constexpr float THRUST_POWER = 0.12f;      // Upward acceleration from main thruster
constexpr float SIDE_THRUST_POWER = 0.08f; // Horizontal acceleration from side thrusters
constexpr float MAX_VELOCITY = 15.0f;      // Terminal velocity
constexpr float SAFE_LANDING_SPEED = 1.5f; // Maximum safe landing velocity
constexpr float FUEL_USAGE_MAIN = 0.3f;    // Fuel consumed per frame for main thruster
constexpr float FUEL_USAGE_SIDE = 0.15f;    // Fuel consumed per frame for side thrusters
constexpr float INITIAL_FUEL = 100.0f;     // Starting fuel amount
constexpr int TERRAIN_POINTS = 100;        // Number of terrain vertices
constexpr int MIN_LANDING_PAD_WIDTH = 40;  // Minimum width of landing pad
constexpr int MAX_LANDING_PAD_WIDTH = 80;  // Maximum width of landing pad
constexpr int LANDER_WIDTH = 20;           // Width of lander
constexpr int LANDER_HEIGHT = 20;          // Height of lander
constexpr int MAX_HIGH_SCORES = 10;        // Number of high scores to track
constexpr int STAR_COUNT = 100;            // Number of background stars

// Scoring constants
constexpr int SCORE_BASE_LANDING = 100;    // Base score for successful landing
constexpr int SCORE_FUEL_BONUS = 2;        // Points per unit of remaining fuel
constexpr int SCORE_SPEED_BONUS = 50;      // Bonus for gentle landing
constexpr int SCORE_CENTER_BONUS = 100;    // Bonus for landing in center of pad

// ============================================================================
// Core Data Structures
// ============================================================================

/**
 * @brief 2D vector for position and velocity
 */
struct Vector2 {
    float x{0.0f};
    float y{0.0f};

    constexpr Vector2() = default;
    constexpr Vector2(float _x, float _y) : x(_x), y(_y) {}

    constexpr Vector2 operator+(const Vector2& v) const noexcept {
        return Vector2(x + v.x, y + v.y);
    }

    constexpr Vector2 operator-(const Vector2& v) const noexcept {
        return Vector2(x - v.x, y - v.y);
    }

    constexpr Vector2 operator*(float scalar) const noexcept {
        return Vector2(x * scalar, y * scalar);
    }

    Vector2& operator+=(const Vector2& v) noexcept {
        x += v.x;
        y += v.y;
        return *this;
    }

    float length() const noexcept {
        return std::sqrt(x * x + y * y);
    }
};

/**
 * @brief Lunar lander spacecraft
 */
struct Lander {
    Vector2 pos{WINDOW_WIDTH / 2.0f, 50.0f}; // Current position
    Vector2 vel{0.0f, 0.0f};                 // Current velocity
    float fuel{INITIAL_FUEL};                // Remaining fuel
    float rotation{0.0f};                    // Rotation angle in radians
    bool mainThrusterOn{false};              // Main thruster state
    bool leftThrusterOn{false};              // Left thruster state
    bool rightThrusterOn{false};             // Right thruster state
    bool crashed{false};                     // Crash state
    bool landed{false};                      // Landed state
};

/**
 * @brief Terrain point
 */
struct TerrainPoint {
    int x{0};
    int y{0};
    bool isLandingPad{false};  // True if this segment is a landing pad
};

/**
 * @brief Particle for explosion effects
 */
struct Particle {
    Vector2 pos;
    Vector2 vel;
    int lifetime{0};  // Frames remaining
    int maxLifetime{0};
    int type{0};  // 0=fire, 1=smoke, 2=debris, 3=lander_debris, 4=spark, 5=flash
    COLORREF color{RGB(255, 128, 0)};
    float rotation{0.0f};       // For lander debris
    float rotationSpeed{0.0f};  // For lander debris
    Vector2 endPos{0.0f, 0.0f}; // For drawing lines (lander pieces)
    float size{1.0f};           // For variable-sized particles
};

/**
 * @brief Shockwave ring for explosion effect
 */
struct Shockwave {
    Vector2 pos;
    float radius{0.0f};
    float maxRadius{100.0f};
    float expandSpeed{8.0f};
    int lifetime{0};
    int maxLifetime{20};
    COLORREF color{RGB(255, 200, 100)};
};

/**
 * @brief Star for background
 */
struct Star {
    int x{0};
    int y{0};
    int brightness{0};  // 0-255
};

/**
 * @brief High score entry
 */
struct HighScore {
    int score{0};
    int level{1};
    wchar_t name[32]{L"---"};
};

/**
 * @brief Background lander for title screen animation
 */
struct BackgroundLander {
    Vector2 pos{0.0f, 0.0f};
    Vector2 vel{0.0f, 0.0f};
    float rotation{0.0f};
    float targetY{0.0f};           // Where it's trying to land
    bool landed{false};
    bool thrusterOn{false};
    int landedTimer{0};            // How long it's been landed
    float scale{1.0f};             // Size scale for depth effect
};

/**
 * @brief Game state enumeration
 */
enum class GameState {
    TITLE_SCREEN,
    PLAYING,
    PAUSED,
    LANDING_SUCCESS,
    CRASHED,
    GAME_OVER,
    HIGH_SCORES,
    ENTER_NAME,
    CONFIRM_QUIT,   // Confirmation dialog for quit/restart
    SETTINGS        // Settings panel
};

// Confirm quit dialog mode
enum class ConfirmMode {
    QUIT,           // User pressed Q - asking to quit
    RESTART         // User pressed R - asking to restart
};

/**
 * @brief Game settings that can be adjusted by the player
 */
struct GameSettings {
    float gravity{0.05f};           // Default: 0.05
    float thrustPower{0.12f};       // Default: 0.12
    float sideThrustPower{0.08f};   // Default: 0.08
    float initialFuel{100.0f};      // Default: 100
    float safeLandingSpeed{1.5f};   // Default: 1.5

    // Currently selected setting in menu (0-4)
    int selectedOption{0};
};

// ============================================================================
// Global Game State
// ============================================================================

// Game objects
Lander lander;
std::vector<TerrainPoint> terrain;
std::vector<Particle> particles;
std::vector<Shockwave> shockwaves;  // Explosion shockwave rings
std::vector<Star> stars;
std::vector<HighScore> highScores(MAX_HIGH_SCORES);
std::vector<BackgroundLander> backgroundLanders;  // For title screen animation

// Game state
GameState gameState = GameState::TITLE_SCREEN;
GameState previousState = GameState::TITLE_SCREEN;  // State to return to from CONFIRM_QUIT
ConfirmMode confirmMode = ConfirmMode::QUIT;        // What action the user is confirming
int score = 0;
int level = 1;
int lives = 3;
int landingPadStart = 0;  // Index of landing pad start in terrain
int landingPadEnd = 0;    // Index of landing pad end in terrain

// Input state
bool keys[256] = {false};

// UI state
wchar_t playerName[32] = L"";
int nameLength = 0;
int stateTimer = 0;  // Timer for state transitions (moved from local static)

// Random number generator
std::random_device rd;
std::mt19937 gen(rd());

// High score file path
const wchar_t* HIGH_SCORE_FILE = L"lander_scores.dat";

// Settings file path and global settings
const wchar_t* SETTINGS_FILE = L"lander.ini";
GameSettings settings;

// Timing
DWORD lastFrameTime = 0;
constexpr DWORD TARGET_FRAME_TIME = 16;  // ~60 FPS

// Sound state for realistic audio using waveOut
bool thrustSoundActive = false;
HANDLE thrustSoundThread = nullptr;
HWAVEOUT hWaveOut = nullptr;
WAVEHDR waveHeader[2] = {};
bool soundInitialized = false;

// ============================================================================
// Function Prototypes
// ============================================================================

// Initialization
void InitGame();
void InitStars();
void InitTerrain();
void InitLander();
void InitBackgroundLanders();
void UpdateBackgroundLanders();

// Game loop
void UpdateGame();
void RenderGame(HDC hdc);

// Physics
void UpdatePhysics();
void ApplyThrust();
bool CheckTerrainCollision();
bool CheckLandingPadCollision();

// Particles
void SpawnExplosion(const Vector2& pos);
void SpawnLanderDebris(const Vector2& pos, float rotation);
void UpdateParticles();

// High scores
void UpdateHighScores(int newScore, int newLevel);
void SaveHighScores();
void LoadHighScores();
bool IsHighScore(int newScore);

// Settings
void SaveSettings();
void LoadSettings();
void ResetSettings();

// Sound generation
void PlaySound_Thrust();
void StopSound_Thrust();
void PlaySound_Crash();
void PlaySound_Landing();
void PlaySound_MenuSelect();

// Utility
float Lerp(float a, float b, float t);
float Clamp(float value, float min, float max);

// Windows message handling
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

// ============================================================================
// Initialization Functions
// ============================================================================

/**
 * @brief Initialize new game
 */
void InitGame() {
    score = 0;
    level = 1;
    lives = 3;
    gameState = GameState::PLAYING;

    InitLander();
    InitTerrain();
    InitStars();

    particles.clear();
}

/**
 * @brief Initialize background stars
 */
void InitStars() {
    stars.clear();
    std::uniform_int_distribution<> xDist(0, WINDOW_WIDTH);
    std::uniform_int_distribution<> yDist(0, WINDOW_HEIGHT / 2);
    std::uniform_int_distribution<> brightDist(50, 255);

    for (int i = 0; i < STAR_COUNT; i++) {
        Star star;
        star.x = xDist(gen);
        star.y = yDist(gen);
        star.brightness = brightDist(gen);
        stars.push_back(star);
    }
}

/**
 * @brief Generate random terrain with landing pad
 */
void InitTerrain() {
    terrain.clear();

    // Generate terrain heights
    std::uniform_int_distribution<> heightDist(
        WINDOW_HEIGHT - 200 + (level * 5),  // Terrain gets higher each level
        WINDOW_HEIGHT - 50
    );
    std::uniform_int_distribution<> roughnessDist(
        -20 - (level * 2),  // Terrain gets rougher each level
        20 + (level * 2)
    );

    int segmentWidth = WINDOW_WIDTH / TERRAIN_POINTS;
    int currentHeight = heightDist(gen);

    // Choose random location for landing pad
    std::uniform_int_distribution<> padPosDist(
        TERRAIN_POINTS / 4,
        (TERRAIN_POINTS * 3) / 4
    );
    int padPosition = padPosDist(gen);
    int padWidth = (MIN_LANDING_PAD_WIDTH + MAX_LANDING_PAD_WIDTH) / (2 * segmentWidth);

    landingPadStart = padPosition;
    landingPadEnd = padPosition + padWidth;

    // Generate terrain points
    for (int i = 0; i < TERRAIN_POINTS; i++) {
        TerrainPoint point;
        point.x = i * segmentWidth;

        // Landing pad is flat
        if (i >= landingPadStart && i < landingPadEnd) {
            point.y = currentHeight;
            point.isLandingPad = true;
        } else {
            currentHeight += roughnessDist(gen);
            currentHeight = static_cast<int>(Clamp(
                static_cast<float>(currentHeight),
                static_cast<float>(WINDOW_HEIGHT - 200),
                static_cast<float>(WINDOW_HEIGHT - 50)
            ));
            point.y = currentHeight;
            point.isLandingPad = false;
        }

        terrain.push_back(point);
    }

    // Ensure last point connects to edge
    terrain.back().x = WINDOW_WIDTH;
}

/**
 * @brief Initialize lander at start position
 */
void InitLander() {
    lander.pos = Vector2(WINDOW_WIDTH / 2.0f, 50.0f);
    lander.vel = Vector2(0.0f, 0.0f);
    lander.fuel = settings.initialFuel + (level * 10.0f);  // Bonus fuel each level
    lander.rotation = 0.0f;
    lander.mainThrusterOn = false;
    lander.leftThrusterOn = false;
    lander.rightThrusterOn = false;
    lander.crashed = false;
    lander.landed = false;
}

/**
 * @brief Initialize background landers for title screen animation
 */
void InitBackgroundLanders() {
    backgroundLanders.clear();

    std::uniform_real_distribution<float> xDist(50.0f, WINDOW_WIDTH - 50.0f);
    std::uniform_real_distribution<float> yDist(-100.0f, 100.0f);
    std::uniform_real_distribution<float> scaleDist(0.4f, 0.8f);
    std::uniform_real_distribution<float> targetYDist(WINDOW_HEIGHT - 120.0f, WINDOW_HEIGHT - 60.0f);

    for (int i = 0; i < 5; i++) {
        BackgroundLander bl;
        bl.pos = Vector2(xDist(gen), yDist(gen));
        bl.vel = Vector2(0.0f, 0.3f);  // Slow descent
        bl.rotation = 0.0f;
        bl.targetY = targetYDist(gen);
        bl.landed = false;
        bl.thrusterOn = false;
        bl.landedTimer = 0;
        bl.scale = scaleDist(gen);
        backgroundLanders.push_back(bl);
    }
}

/**
 * @brief Update background landers - simple AI landing behavior
 */
void UpdateBackgroundLanders() {
    std::uniform_real_distribution<float> xDist(50.0f, WINDOW_WIDTH - 50.0f);
    std::uniform_real_distribution<float> yDist(-150.0f, -50.0f);
    std::uniform_real_distribution<float> scaleDist(0.4f, 0.8f);
    std::uniform_real_distribution<float> targetYDist(WINDOW_HEIGHT - 120.0f, WINDOW_HEIGHT - 60.0f);

    for (auto& bl : backgroundLanders) {
        if (bl.landed) {
            bl.landedTimer++;
            // After landing for a while, reset and start again
            if (bl.landedTimer > 300) {  // ~5 seconds
                bl.pos = Vector2(xDist(gen), yDist(gen));
                bl.vel = Vector2(0.0f, 0.3f);
                bl.targetY = targetYDist(gen);
                bl.landed = false;
                bl.landedTimer = 0;
                bl.scale = scaleDist(gen);
            }
            continue;
        }

        // Apply gravity (scaled down for background effect)
        bl.vel.y += GRAVITY * 0.3f * bl.scale;

        // Simple landing AI - slow down when approaching target
        float distanceToGround = bl.targetY - bl.pos.y;

        if (distanceToGround < 100.0f && bl.vel.y > 0.5f) {
            // Fire thrusters to slow down
            bl.thrusterOn = true;
            bl.vel.y -= THRUST_POWER * 0.4f * bl.scale;
        } else if (distanceToGround < 50.0f && bl.vel.y > 0.2f) {
            // Final approach - very gentle
            bl.thrusterOn = true;
            bl.vel.y -= THRUST_POWER * 0.3f * bl.scale;
        } else {
            bl.thrusterOn = false;
        }

        // Clamp velocity
        bl.vel.y = Clamp(bl.vel.y, -2.0f, 3.0f);

        // Update position
        bl.pos += bl.vel;

        // Check if landed
        if (bl.pos.y >= bl.targetY && bl.vel.y >= 0) {
            bl.pos.y = bl.targetY;
            bl.vel = Vector2(0.0f, 0.0f);
            bl.landed = true;
            bl.thrusterOn = false;
        }
    }
}

// ============================================================================
// Game Loop Functions
// ============================================================================

/**
 * @brief Update game state
 */
void UpdateGame() {
    switch (gameState) {
        case GameState::PLAYING:
            ApplyThrust();
            UpdatePhysics();
            UpdateParticles();

            // Check for crash or landing
            if (CheckTerrainCollision()) {
                if (CheckLandingPadCollision() &&
                    lander.vel.length() < settings.safeLandingSpeed &&
                    std::abs(lander.rotation) < 0.2f) {
                    // Successful landing
                    lander.landed = true;
                    lander.vel = Vector2(0.0f, 0.0f);
                    gameState = GameState::LANDING_SUCCESS;
                    stateTimer = 0;  // Reset timer for state transition
                    StopSound_Thrust();  // Stop thrust sound on landing
                    PlaySound_Landing();

                    // Calculate score
                    int landingScore = SCORE_BASE_LANDING;
                    landingScore += static_cast<int>(lander.fuel) * SCORE_FUEL_BONUS;
                    if (lander.vel.length() < settings.safeLandingSpeed / 2.0f) {
                        landingScore += SCORE_SPEED_BONUS;
                    }
                    // Check if landed in center of pad
                    float padCenterX = (terrain[landingPadStart].x + terrain[landingPadEnd].x) / 2.0f;
                    if (std::abs(lander.pos.x - padCenterX) < 20.0f) {
                        landingScore += SCORE_CENTER_BONUS;
                    }
                    score += landingScore * level;  // Multiply by level
                } else {
                    // Crash
                    lander.crashed = true;
                    lander.vel = Vector2(0.0f, 0.0f);
                    gameState = GameState::CRASHED;
                    stateTimer = 0;  // Reset timer for state transition
                    StopSound_Thrust();  // Stop thrust sound on crash
                    Sleep(50);  // Brief delay to let audio device stabilize
                    SpawnExplosion(lander.pos);
                    SpawnLanderDebris(lander.pos, lander.rotation);  // Break apart lander
                    PlaySound_Crash();
                    lives--;
                }
            }
            break;

        case GameState::LANDING_SUCCESS:
        case GameState::CRASHED:
            UpdateParticles();

            // Auto-advance after delay (stateTimer is global, reset on state entry)
            stateTimer++;
            if (stateTimer > 120) {  // 2 seconds at 60 FPS
                stateTimer = 0;

                if (gameState == GameState::LANDING_SUCCESS) {
                    level++;
                    InitLander();
                    InitTerrain();
                    gameState = GameState::PLAYING;
                } else {
                    if (lives > 0) {
                        InitLander();
                        gameState = GameState::PLAYING;
                    } else {
                        if (IsHighScore(score)) {
                            gameState = GameState::ENTER_NAME;
                            nameLength = 0;
                            playerName[0] = L'\0';
                        } else {
                            gameState = GameState::GAME_OVER;
                        }
                    }
                }
            }
            break;

        default:
            break;
    }
}

/**
 * @brief Apply thrust based on input
 */
void ApplyThrust() {
    lander.mainThrusterOn = false;
    lander.leftThrusterOn = false;
    lander.rightThrusterOn = false;

    if (lander.fuel <= 0.0f) {
        StopSound_Thrust();
        return;
    }

    // Main thruster (up arrow, W, or spacebar)
    if (keys[VK_UP] || keys['W'] || keys[VK_SPACE]) {
        if (lander.fuel >= FUEL_USAGE_MAIN) {
            lander.mainThrusterOn = true;
            lander.vel.y -= settings.thrustPower * std::cos(lander.rotation);
            lander.vel.x += settings.thrustPower * std::sin(lander.rotation);
            lander.fuel -= FUEL_USAGE_MAIN;
            PlaySound_Thrust();  // Start continuous thrust sound
        }
    } else {
        StopSound_Thrust();  // Stop sound when thruster is off
    }

    // Left thruster (left arrow or A)
    if (keys[VK_LEFT] || keys['A']) {
        if (lander.fuel >= FUEL_USAGE_SIDE) {
            lander.leftThrusterOn = true;
            lander.rotation -= 0.05f;
            lander.fuel -= FUEL_USAGE_SIDE;
        }
    }

    // Right thruster (right arrow or D)
    if (keys[VK_RIGHT] || keys['D']) {
        if (lander.fuel >= FUEL_USAGE_SIDE) {
            lander.rightThrusterOn = true;
            lander.rotation += 0.05f;
            lander.fuel -= FUEL_USAGE_SIDE;
        }
    }

    // Clamp rotation
    lander.rotation = Clamp(lander.rotation, -1.57f, 1.57f);  // Â±90 degrees
}

/**
 * @brief Update physics simulation
 */
void UpdatePhysics() {
    // Apply gravity
    lander.vel.y += settings.gravity;

    // Clamp velocity
    if (lander.vel.length() > MAX_VELOCITY) {
        float ratio = MAX_VELOCITY / lander.vel.length();
        lander.vel.x *= ratio;
        lander.vel.y *= ratio;
    }

    // Update position
    lander.pos += lander.vel;

    // Wrap horizontally
    if (lander.pos.x < 0) lander.pos.x = WINDOW_WIDTH;
    if (lander.pos.x > WINDOW_WIDTH) lander.pos.x = 0;
}

/**
 * @brief Check collision with terrain
 */
bool CheckTerrainCollision() {
    // Get lander bottom point
    float landerBottom = lander.pos.y + LANDER_HEIGHT / 2.0f;
    int landerX = static_cast<int>(lander.pos.x);

    // Find terrain segment
    int segmentWidth = WINDOW_WIDTH / TERRAIN_POINTS;
    int segment = landerX / segmentWidth;
    if (segment < 0 || segment >= static_cast<int>(terrain.size()) - 1) {
        return false;
    }

    // Interpolate terrain height at lander position
    float t = static_cast<float>(landerX % segmentWidth) / segmentWidth;
    float terrainHeight = Lerp(
        static_cast<float>(terrain[segment].y),
        static_cast<float>(terrain[segment + 1].y),
        t
    );

    return landerBottom >= terrainHeight;
}

/**
 * @brief Check if collision is on landing pad
 */
bool CheckLandingPadCollision() {
    int landerX = static_cast<int>(lander.pos.x);
    int segmentWidth = WINDOW_WIDTH / TERRAIN_POINTS;
    int segment = landerX / segmentWidth;

    return segment >= landingPadStart && segment < landingPadEnd;
}

// ============================================================================
// Particle System
// ============================================================================

/**
 * @brief Spawn classic arcade explosion - dramatic BOOM effect!
 * Creates a multi-layered explosion with flash, fireball, sparks, and shockwave
 */
void SpawnExplosion(const Vector2& pos) {
    // Random distributions for variety
    std::uniform_real_distribution<float> angleDist(0.0f, 6.28318f);
    std::uniform_real_distribution<float> speedDist(2.0f, 12.0f);
    std::uniform_real_distribution<float> slowSpeedDist(0.5f, 3.0f);
    std::uniform_real_distribution<float> sparkSpeedDist(8.0f, 18.0f);
    std::uniform_real_distribution<float> sizeDist(1.0f, 4.0f);
    std::uniform_int_distribution<int> shortLife(8, 20);
    std::uniform_int_distribution<int> medLife(25, 50);
    std::uniform_int_distribution<int> longLife(50, 90);
    std::uniform_int_distribution<int> fireColorG(80, 200);
    std::uniform_int_distribution<int> sparkColorR(200, 255);
    std::uniform_int_distribution<int> sparkColorG(150, 255);

    // === LAYER 1: Initial bright flash (the "BOOM" moment) ===
    for (int i = 0; i < 8; i++) {
        Particle p;
        p.pos = pos;
        p.type = 5;  // Flash type
        float angle = angleDist(gen);
        float speed = slowSpeedDist(gen);
        p.vel = Vector2(std::cos(angle) * speed, std::sin(angle) * speed);
        p.maxLifetime = shortLife(gen);
        p.lifetime = p.maxLifetime;
        p.color = RGB(255, 255, 200);  // Bright white-yellow flash
        p.size = 6.0f + sizeDist(gen);
        particles.push_back(p);
    }

    // === LAYER 2: Fireball core (expanding orange-red mass) ===
    for (int i = 0; i < 60; i++) {
        Particle p;
        p.pos = pos;
        p.type = 0;  // Fire
        float angle = angleDist(gen);
        float speed = speedDist(gen);
        p.vel = Vector2(
            std::cos(angle) * speed,
            std::sin(angle) * speed - 1.5f  // Slight upward bias
        );
        p.maxLifetime = medLife(gen);
        p.lifetime = p.maxLifetime;
        // Fire colors: bright yellow center to dark red edges
        int g = fireColorG(gen);
        p.color = RGB(255, g, 0);
        p.size = sizeDist(gen);
        particles.push_back(p);
    }

    // === LAYER 3: Hot sparks (fast streaking particles) ===
    for (int i = 0; i < 40; i++) {
        Particle p;
        p.pos = pos;
        p.type = 4;  // Spark
        float angle = angleDist(gen);
        float speed = sparkSpeedDist(gen);
        p.vel = Vector2(std::cos(angle) * speed, std::sin(angle) * speed);
        p.maxLifetime = shortLife(gen) + 10;
        p.lifetime = p.maxLifetime;
        // Hot white/yellow sparks
        p.color = RGB(sparkColorR(gen), sparkColorG(gen), 100);
        p.size = 1.0f;
        // Store spark trail direction
        p.endPos = Vector2(std::cos(angle) * 8.0f, std::sin(angle) * 8.0f);
        particles.push_back(p);
    }

    // === LAYER 4: Secondary explosions (delayed fireballs) ===
    std::uniform_real_distribution<float> offsetDist(-15.0f, 15.0f);
    for (int i = 0; i < 25; i++) {
        Particle p;
        p.pos = Vector2(pos.x + offsetDist(gen), pos.y + offsetDist(gen));
        p.type = 0;  // Fire
        float angle = angleDist(gen);
        float speed = speedDist(gen) * 0.7f;
        p.vel = Vector2(
            std::cos(angle) * speed,
            std::sin(angle) * speed - 2.0f
        );
        p.maxLifetime = medLife(gen) + 15;  // Slightly delayed
        p.lifetime = p.maxLifetime;
        int g = fireColorG(gen);
        p.color = RGB(255, g, g / 4);  // More reddish
        p.size = sizeDist(gen) * 1.5f;
        particles.push_back(p);
    }

    // === LAYER 5: Smoke cloud (rising, long-lasting) ===
    std::uniform_int_distribution<int> grayDist(60, 140);
    for (int i = 0; i < 35; i++) {
        Particle p;
        p.pos = Vector2(pos.x + offsetDist(gen), pos.y + offsetDist(gen));
        p.type = 1;  // Smoke
        float angle = angleDist(gen);
        float speed = slowSpeedDist(gen);
        p.vel = Vector2(
            std::cos(angle) * speed * 0.5f,
            -std::abs(std::sin(angle) * speed) - 0.5f  // Always float up
        );
        p.maxLifetime = longLife(gen);
        p.lifetime = p.maxLifetime;
        int gray = grayDist(gen);
        p.color = RGB(gray, gray, gray);
        p.size = sizeDist(gen) * 2.0f;
        particles.push_back(p);
    }

    // === LAYER 6: Metal debris (shrapnel flying outward) ===
    std::uniform_int_distribution<int> metalDist(150, 220);
    for (int i = 0; i < 20; i++) {
        Particle p;
        p.pos = pos;
        p.type = 2;  // Debris
        float angle = angleDist(gen);
        float speed = speedDist(gen) * 1.2f;
        p.vel = Vector2(std::cos(angle) * speed, std::sin(angle) * speed);
        p.maxLifetime = medLife(gen) + 20;
        p.lifetime = p.maxLifetime;
        int metal = metalDist(gen);
        p.color = RGB(metal, metal, metal);
        p.size = 2.0f;
        particles.push_back(p);
    }

    // === SHOCKWAVE RINGS ===
    // Primary shockwave (fast, large)
    Shockwave sw1;
    sw1.pos = pos;
    sw1.radius = 5.0f;
    sw1.maxRadius = 80.0f;
    sw1.expandSpeed = 6.0f;
    sw1.lifetime = 0;
    sw1.maxLifetime = 15;
    sw1.color = RGB(255, 200, 100);
    shockwaves.push_back(sw1);

    // Secondary shockwave (slower, follows primary)
    Shockwave sw2;
    sw2.pos = pos;
    sw2.radius = 0.0f;
    sw2.maxRadius = 60.0f;
    sw2.expandSpeed = 4.0f;
    sw2.lifetime = 0;
    sw2.maxLifetime = 20;
    sw2.color = RGB(255, 150, 50);
    shockwaves.push_back(sw2);

    // Tertiary ring (dramatic outer edge)
    Shockwave sw3;
    sw3.pos = pos;
    sw3.radius = 0.0f;
    sw3.maxRadius = 100.0f;
    sw3.expandSpeed = 8.0f;
    sw3.lifetime = 0;
    sw3.maxLifetime = 12;
    sw3.color = RGB(255, 255, 200);
    shockwaves.push_back(sw3);
}

/**
 * @brief Spawn lander debris pieces - visual breakup on crash
 */
void SpawnLanderDebris(const Vector2& pos, float rotation) {
    std::uniform_real_distribution<float> velDist(-4.0f, 4.0f);
    std::uniform_real_distribution<float> spinDist(-0.2f, 0.2f);
    std::uniform_real_distribution<float> rotationOffset(-0.5f, 0.5f);
    std::uniform_real_distribution<float> fullRotation(0.0f, 6.28318f);
    std::uniform_int_distribution<int> lifeDist(60, 120);
    std::uniform_int_distribution<int> legLengthDist(10, 14);

    // Create debris pieces representing lander structure breaking apart
    // Each piece is a line segment with endpoints

    // Body fragments (4 pieces from the main body)
    for (int i = 0; i < 4; i++) {
        Particle p;
        p.type = 3;  // Lander debris
        p.pos = pos;
        p.vel = Vector2(
            velDist(gen),
            velDist(gen) - 2.0f  // Initial upward burst
        );
        p.rotation = rotation + rotationOffset(gen);
        p.rotationSpeed = spinDist(gen);
        p.maxLifetime = lifeDist(gen);
        p.lifetime = p.maxLifetime;
        p.color = RGB(220, 220, 220);  // Lander color

        // Different body pieces
        switch (i) {
            case 0: p.endPos = Vector2(16.0f, 0.0f); break;   // Top piece
            case 1: p.endPos = Vector2(-16.0f, 0.0f); break;  // Bottom piece
            case 2: p.endPos = Vector2(0.0f, 12.0f); break;   // Side piece
            case 3: p.endPos = Vector2(0.0f, -12.0f); break;  // Other side
        }

        particles.push_back(p);
    }

    // Landing leg fragments (4 legs breaking off)
    for (int i = 0; i < 4; i++) {
        Particle p;
        p.type = 3;  // Lander debris
        p.pos = pos;
        p.vel = Vector2(
            velDist(gen) * 1.5f,  // Legs fly farther
            velDist(gen)
        );
        p.rotation = rotation + fullRotation(gen);  // Random rotation
        p.rotationSpeed = spinDist(gen) * 2.0f;  // Spin faster
        p.maxLifetime = lifeDist(gen);
        p.lifetime = p.maxLifetime;
        p.color = RGB(180, 180, 180);  // Slightly darker for legs
        p.endPos = Vector2(static_cast<float>(legLengthDist(gen)), 0.0f);  // Leg length

        particles.push_back(p);
    }
}

/**
 * @brief Update all particles and shockwaves
 */
void UpdateParticles() {
    // Update particles
    for (auto it = particles.begin(); it != particles.end();) {
        it->pos += it->vel;

        // Different gravity for different particle types
        switch (it->type) {
            case 0:  // Fire - slight upward drift
                it->vel.y += GRAVITY * 0.3f;
                it->vel.x *= 0.98f;  // Air resistance
                it->vel.y *= 0.98f;
                break;
            case 1:  // Smoke - floats up
                it->vel.y -= 0.02f;
                it->vel.x *= 0.95f;
                break;
            case 2:  // Debris - full gravity
                it->vel.y += GRAVITY * 0.8f;
                break;
            case 3:  // Lander debris - gravity with spin
                it->vel.y += GRAVITY * 0.6f;
                it->rotation += it->rotationSpeed;
                break;
            case 4:  // Sparks - fast with drag
                it->vel.y += GRAVITY * 0.4f;
                it->vel.x *= 0.96f;
                it->vel.y *= 0.96f;
                break;
            case 5:  // Flash - expands then fades
                it->size *= 0.92f;  // Shrink rapidly
                break;
        }

        it->lifetime--;

        if (it->lifetime <= 0) {
            it = particles.erase(it);
        } else {
            ++it;
        }
    }

    // Update shockwaves
    for (auto it = shockwaves.begin(); it != shockwaves.end();) {
        it->radius += it->expandSpeed;
        it->lifetime++;

        if (it->lifetime >= it->maxLifetime || it->radius >= it->maxRadius) {
            it = shockwaves.erase(it);
        } else {
            ++it;
        }
    }
}

// ============================================================================
// Rendering Functions
// ============================================================================

/**
 * @brief Render game scene
 */
void RenderGame(HDC hdc) {
    // Create double buffer
    static HDC hdcMem = nullptr;
    static HBITMAP hbmMem = nullptr;

    if (!hdcMem) {
        hdcMem = CreateCompatibleDC(hdc);
        hbmMem = CreateCompatibleBitmap(hdc, WINDOW_WIDTH, WINDOW_HEIGHT);
        SelectObject(hdcMem, hbmMem);
    }

    // Clear background (space)
    RECT rect = {0, 0, WINDOW_WIDTH, WINDOW_HEIGHT};
    HBRUSH hBrushBlack = CreateSolidBrush(RGB(0, 0, 20));
    FillRect(hdcMem, &rect, hBrushBlack);
    DeleteObject(hBrushBlack);

    // Draw stars
    for (const auto& star : stars) {
        SetPixel(hdcMem, star.x, star.y, RGB(star.brightness, star.brightness, star.brightness));
    }

    switch (gameState) {
        case GameState::TITLE_SCREEN: {
            // Update and draw background landers (behind everything)
            UpdateBackgroundLanders();

            // Draw simple ground line for background landers
            HPEN hPenGround = CreatePen(PS_SOLID, 1, RGB(60, 60, 80));
            HPEN hOldPen = (HPEN)SelectObject(hdcMem, hPenGround);
            MoveToEx(hdcMem, 0, WINDOW_HEIGHT - 50, nullptr);
            LineTo(hdcMem, WINDOW_WIDTH, WINDOW_HEIGHT - 50);
            SelectObject(hdcMem, hOldPen);
            DeleteObject(hPenGround);

            // Draw each background lander
            for (const auto& bl : backgroundLanders) {
                // Calculate alpha/brightness based on scale (depth)
                int brightness = static_cast<int>(120 + bl.scale * 100);
                COLORREF landerColor = RGB(brightness, brightness, brightness);

                HPEN hPenLander = CreatePen(PS_SOLID, static_cast<int>(1 + bl.scale), landerColor);
                hOldPen = (HPEN)SelectObject(hdcMem, hPenLander);

                float cos_r = std::cos(bl.rotation);
                float sin_r = std::sin(bl.rotation);
                float s = bl.scale;

                // Helper to transform points with scale
                auto transformBgPoint = [&](float x, float y) -> POINT {
                    POINT pt;
                    pt.x = static_cast<LONG>(bl.pos.x + (x * cos_r - y * sin_r) * s);
                    pt.y = static_cast<LONG>(bl.pos.y + (x * sin_r + y * cos_r) * s);
                    return pt;
                };

                // Draw body (simplified)
                POINT body[5];
                body[0] = transformBgPoint(-8, -4);
                body[1] = transformBgPoint(8, -4);
                body[2] = transformBgPoint(8, 4);
                body[3] = transformBgPoint(-8, 4);
                body[4] = body[0];
                Polyline(hdcMem, body, 5);

                // Draw legs
                POINT leg1Start = transformBgPoint(-8, 4);
                POINT leg1End = transformBgPoint(-12, 10);
                MoveToEx(hdcMem, leg1Start.x, leg1Start.y, nullptr);
                LineTo(hdcMem, leg1End.x, leg1End.y);

                POINT leg2Start = transformBgPoint(8, 4);
                POINT leg2End = transformBgPoint(12, 10);
                MoveToEx(hdcMem, leg2Start.x, leg2Start.y, nullptr);
                LineTo(hdcMem, leg2End.x, leg2End.y);

                // Draw thruster flame if active
                if (bl.thrusterOn) {
                    HPEN hPenFlame = CreatePen(PS_SOLID, static_cast<int>(2 * s), RGB(255, 150, 50));
                    SelectObject(hdcMem, hPenFlame);

                    static std::uniform_int_distribution<int> bgFlameDist(0, 3);
                    int flameLen = static_cast<int>((8 + bgFlameDist(gen)) * s);
                    POINT flameStart = transformBgPoint(0, 4);
                    POINT flameEnd = transformBgPoint(0, 4 + flameLen);
                    MoveToEx(hdcMem, flameStart.x, flameStart.y, nullptr);
                    LineTo(hdcMem, flameEnd.x, flameEnd.y);

                    DeleteObject(hPenFlame);
                    SelectObject(hdcMem, hPenLander);
                }

                SelectObject(hdcMem, hOldPen);
                DeleteObject(hPenLander);
            }

            // Title
            SetTextColor(hdcMem, RGB(255, 255, 255));
            SetBkMode(hdcMem, TRANSPARENT);

            HFONT hFont = CreateFont(48, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
                                     DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                     CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            HFONT hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            RECT titleRect = {0, 100, WINDOW_WIDTH, 150};
            DrawText(hdcMem, L"LUNAR LANDER", -1, &titleRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);

            // Version and copyright info
            hFont = CreateFont(16, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                              DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                              CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            SetTextColor(hdcMem, RGB(180, 180, 180));
            RECT versionRect = {0, 160, WINDOW_WIDTH, 180};
            DrawText(hdcMem, L"v" LANDER_VERSION_STRING, -1, &versionRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            RECT copyrightRect = {0, 180, WINDOW_WIDTH, 200};
            DrawText(hdcMem, L"Copyright (c) 2025 Todd Dube", -1, &copyrightRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            RECT githubRect = {0, 200, WINDOW_WIDTH, 220};
            DrawText(hdcMem, L"github.com/todddube/lander", -1, &githubRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);

            // Instructions
            SetTextColor(hdcMem, RGB(255, 255, 255));
            hFont = CreateFont(20, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                              DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                              CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            const wchar_t* instructions[] = {
                L"ARROW KEYS or WASD to control",
                L"SPACEBAR for main thruster",
                L"Land gently on the green landing pad",
                L"Watch your fuel and velocity!",
                L"",
                L"SPACE start | H scores | S settings | Q quit"
            };

            int y = 280;
            for (const auto* text : instructions) {
                RECT textRect = {0, y, WINDOW_WIDTH, y + 25};
                DrawText(hdcMem, text, -1, &textRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
                y += 30;
            }

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);
            break;
        }

        case GameState::PLAYING:
        case GameState::LANDING_SUCCESS:
        case GameState::CRASHED: {
            // Draw terrain with retro jagged mountain look
            HPEN hPenTerrain = CreatePen(PS_SOLID, 2, RGB(180, 180, 180));
            HPEN hOldPen = (HPEN)SelectObject(hdcMem, hPenTerrain);
            HBRUSH hBrushTerrain = CreateSolidBrush(RGB(80, 80, 80));
            HBRUSH hOldBrush = (HBRUSH)SelectObject(hdcMem, hBrushTerrain);

            // Build polygon for filled terrain
            std::vector<POINT> terrainPolygon;
            for (size_t i = 0; i < terrain.size(); i++) {
                POINT pt;
                pt.x = terrain[i].x;
                pt.y = terrain[i].y;
                terrainPolygon.push_back(pt);
            }
            // Add bottom corners to close polygon
            POINT bottomRight = {WINDOW_WIDTH, WINDOW_HEIGHT};
            POINT bottomLeft = {0, WINDOW_HEIGHT};
            terrainPolygon.push_back(bottomRight);
            terrainPolygon.push_back(bottomLeft);

            // Fill terrain
            Polygon(hdcMem, terrainPolygon.data(), static_cast<int>(terrainPolygon.size()));

            // Draw landing pad with velocity-based color
            // Determine pad color based on current velocity
            COLORREF padColor;
            float velocity = lander.vel.length();
            if (velocity <= settings.safeLandingSpeed * 0.5f) {
                // Safe - green
                padColor = RGB(0, 255, 0);
            } else if (velocity <= settings.safeLandingSpeed) {
                // Caution - yellow
                padColor = RGB(255, 255, 0);
            } else {
                // Danger - red
                padColor = RGB(255, 0, 0);
            }

            // Draw the flat landing pad as a single horizontal line
            if (landingPadStart < static_cast<int>(terrain.size()) &&
                landingPadEnd <= static_cast<int>(terrain.size())) {
                HPEN hPenPad = CreatePen(PS_SOLID, 4, padColor);
                SelectObject(hdcMem, hPenPad);

                // Draw single flat line across entire pad
                int padY = terrain[landingPadStart].y;
                int padStartX = terrain[landingPadStart].x;
                int padEndX = terrain[landingPadEnd].x;

                MoveToEx(hdcMem, padStartX, padY, nullptr);
                LineTo(hdcMem, padEndX, padY);

                DeleteObject(hPenPad);
                SelectObject(hdcMem, hPenTerrain);
            }

            SelectObject(hdcMem, hOldBrush);
            DeleteObject(hBrushTerrain);
            SelectObject(hdcMem, hOldPen);
            DeleteObject(hPenTerrain);

            // Draw shockwave rings FIRST (behind particles)
            for (const auto& sw : shockwaves) {
                float alpha = 1.0f - (static_cast<float>(sw.lifetime) / sw.maxLifetime);
                int r = static_cast<int>(GetRValue(sw.color) * alpha);
                int g = static_cast<int>(GetGValue(sw.color) * alpha);
                int b = static_cast<int>(GetBValue(sw.color) * alpha);

                // Draw expanding ring
                int thickness = static_cast<int>(3.0f * alpha);
                if (thickness < 1) thickness = 1;
                HPEN hPenRing = CreatePen(PS_SOLID, thickness, RGB(r, g, b));
                HPEN hOldPenRing = (HPEN)SelectObject(hdcMem, hPenRing);
                SelectObject(hdcMem, GetStockObject(NULL_BRUSH));

                int cx = static_cast<int>(sw.pos.x);
                int cy = static_cast<int>(sw.pos.y);
                int rad = static_cast<int>(sw.radius);
                Ellipse(hdcMem, cx - rad, cy - rad, cx + rad, cy + rad);

                SelectObject(hdcMem, hOldPenRing);
                DeleteObject(hPenRing);
            }

            // Draw particles with enhanced rendering
            for (const auto& p : particles) {
                float alpha = static_cast<float>(p.lifetime) / p.maxLifetime;

                // Calculate faded color based on lifetime
                int r = static_cast<int>(GetRValue(p.color) * alpha);
                int g = static_cast<int>(GetGValue(p.color) * alpha);
                int b = static_cast<int>(GetBValue(p.color) * alpha);

                COLORREF fadedColor = RGB(r, g, b);
                int px = static_cast<int>(p.pos.x);
                int py = static_cast<int>(p.pos.y);

                switch (p.type) {
                    case 0:  // Fire - draw as glowing blob
                    {
                        int size = static_cast<int>(p.size * alpha);
                        if (size < 1) size = 1;
                        // Draw core
                        for (int dx = -size; dx <= size; dx++) {
                            for (int dy = -size; dy <= size; dy++) {
                                if (dx*dx + dy*dy <= size*size) {
                                    SetPixel(hdcMem, px + dx, py + dy, fadedColor);
                                }
                            }
                        }
                        break;
                    }

                    case 1:  // Smoke - larger, softer blob
                    {
                        int size = static_cast<int>(p.size * (0.5f + alpha * 0.5f));
                        if (size < 1) size = 1;
                        for (int dx = -size; dx <= size; dx++) {
                            for (int dy = -size; dy <= size; dy++) {
                                if (dx*dx + dy*dy <= size*size) {
                                    SetPixel(hdcMem, px + dx, py + dy, fadedColor);
                                }
                            }
                        }
                        break;
                    }

                    case 2:  // Metal debris - small squares
                    {
                        int size = static_cast<int>(p.size);
                        for (int dx = 0; dx < size; dx++) {
                            for (int dy = 0; dy < size; dy++) {
                                SetPixel(hdcMem, px + dx, py + dy, fadedColor);
                            }
                        }
                        break;
                    }

                    case 3:  // Lander debris - rotating line segments
                    {
                        HPEN hPenDebris = CreatePen(PS_SOLID, 2, fadedColor);
                        HPEN hOldPenDebris = (HPEN)SelectObject(hdcMem, hPenDebris);

                        float cos_r = std::cos(p.rotation);
                        float sin_r = std::sin(p.rotation);

                        int x1 = px;
                        int y1 = py;
                        int x2 = static_cast<int>(p.pos.x + (p.endPos.x * cos_r - p.endPos.y * sin_r));
                        int y2 = static_cast<int>(p.pos.y + (p.endPos.x * sin_r + p.endPos.y * cos_r));

                        MoveToEx(hdcMem, x1, y1, nullptr);
                        LineTo(hdcMem, x2, y2);

                        SelectObject(hdcMem, hOldPenDebris);
                        DeleteObject(hPenDebris);
                        break;
                    }

                    case 4:  // Sparks - streaking lines
                    {
                        HPEN hPenSpark = CreatePen(PS_SOLID, 1, fadedColor);
                        HPEN hOldPenSpark = (HPEN)SelectObject(hdcMem, hPenSpark);

                        // Draw spark with trail
                        int trailLen = static_cast<int>(p.vel.length() * 0.5f);
                        if (trailLen < 2) trailLen = 2;
                        int tx = static_cast<int>(p.pos.x - p.vel.x * 0.3f);
                        int ty = static_cast<int>(p.pos.y - p.vel.y * 0.3f);

                        MoveToEx(hdcMem, tx, ty, nullptr);
                        LineTo(hdcMem, px, py);

                        // Bright tip
                        SetPixel(hdcMem, px, py, RGB(255, 255, 200));

                        SelectObject(hdcMem, hOldPenSpark);
                        DeleteObject(hPenSpark);
                        break;
                    }

                    case 5:  // Flash - bright expanding glow
                    {
                        int size = static_cast<int>(p.size);
                        if (size < 1) size = 1;

                        // Draw bright center
                        COLORREF brightColor = RGB(
                            std::min(255, r + 100),
                            std::min(255, g + 100),
                            std::min(255, b + 50)
                        );

                        for (int dx = -size; dx <= size; dx++) {
                            for (int dy = -size; dy <= size; dy++) {
                                float dist = std::sqrt(static_cast<float>(dx*dx + dy*dy));
                                if (dist <= size) {
                                    // Brighter in center
                                    float intensity = 1.0f - (dist / size);
                                    COLORREF c = (intensity > 0.5f) ? brightColor : fadedColor;
                                    SetPixel(hdcMem, px + dx, py + dy, c);
                                }
                            }
                        }
                        break;
                    }
                }
            }

            // Draw Apollo-style lunar lander (if not crashed)
            if (!lander.crashed) {
                HPEN hPenLander = CreatePen(PS_SOLID, 2, RGB(220, 220, 220));
                hOldPen = (HPEN)SelectObject(hdcMem, hPenLander);

                float cos_r = std::cos(lander.rotation);
                float sin_r = std::sin(lander.rotation);

                // Helper lambda to rotate and translate points
                auto transformPoint = [&](float x, float y) -> POINT {
                    POINT pt;
                    pt.x = static_cast<LONG>(lander.pos.x + (x * cos_r - y * sin_r));
                    pt.y = static_cast<LONG>(lander.pos.y + (x * sin_r + y * cos_r));
                    return pt;
                };

                // Draw descent stage (square body)
                POINT body[5];
                body[0] = transformPoint(-8, -4);
                body[1] = transformPoint(8, -4);
                body[2] = transformPoint(8, 4);
                body[3] = transformPoint(-8, 4);
                body[4] = body[0];
                Polyline(hdcMem, body, 5);

                // Draw ascent stage (smaller top module)
                POINT ascent[5];
                ascent[0] = transformPoint(-5, -8);
                ascent[1] = transformPoint(5, -8);
                ascent[2] = transformPoint(5, -4);
                ascent[3] = transformPoint(-5, -4);
                ascent[4] = ascent[0];
                Polyline(hdcMem, ascent, 5);

                // Draw landing legs (four legs)
                HPEN hPenLegs = CreatePen(PS_SOLID, 1, RGB(180, 180, 180));
                SelectObject(hdcMem, hPenLegs);

                // Left legs
                POINT leftLeg1Start = transformPoint(-8, 4);
                POINT leftLeg1End = transformPoint(-12, 10);
                MoveToEx(hdcMem, leftLeg1Start.x, leftLeg1Start.y, nullptr);
                LineTo(hdcMem, leftLeg1End.x, leftLeg1End.y);

                POINT leftLeg2Start = transformPoint(-4, 4);
                POINT leftLeg2End = transformPoint(-10, 10);
                MoveToEx(hdcMem, leftLeg2Start.x, leftLeg2Start.y, nullptr);
                LineTo(hdcMem, leftLeg2End.x, leftLeg2End.y);

                // Right legs
                POINT rightLeg1Start = transformPoint(4, 4);
                POINT rightLeg1End = transformPoint(10, 10);
                MoveToEx(hdcMem, rightLeg1Start.x, rightLeg1Start.y, nullptr);
                LineTo(hdcMem, rightLeg1End.x, rightLeg1End.y);

                POINT rightLeg2Start = transformPoint(8, 4);
                POINT rightLeg2End = transformPoint(12, 10);
                MoveToEx(hdcMem, rightLeg2Start.x, rightLeg2Start.y, nullptr);
                LineTo(hdcMem, rightLeg2End.x, rightLeg2End.y);

                // Draw foot pads
                MoveToEx(hdcMem, leftLeg1End.x - 2, leftLeg1End.y, nullptr);
                LineTo(hdcMem, leftLeg1End.x + 2, leftLeg1End.y);
                MoveToEx(hdcMem, rightLeg2End.x - 2, rightLeg2End.y, nullptr);
                LineTo(hdcMem, rightLeg2End.x + 2, rightLeg2End.y);

                DeleteObject(hPenLegs);
                SelectObject(hdcMem, hPenLander);

                // Draw main thruster flame
                if (lander.mainThrusterOn) {
                    HPEN hPenFlame = CreatePen(PS_SOLID, 3, RGB(255, 200, 0));
                    SelectObject(hdcMem, hPenFlame);

                    static std::uniform_int_distribution<int> flameDist(0, 3);
                    int flameLength = 12 + flameDist(gen);  // Flickering flame
                    POINT flameStart = transformPoint(0, 4);
                    POINT flameEnd = transformPoint(0, 4 + flameLength);

                    MoveToEx(hdcMem, flameStart.x, flameStart.y, nullptr);
                    LineTo(hdcMem, flameEnd.x, flameEnd.y);

                    // Draw flame spread
                    POINT flameLeft = transformPoint(-2, 4 + flameLength - 3);
                    POINT flameRight = transformPoint(2, 4 + flameLength - 3);
                    MoveToEx(hdcMem, flameStart.x, flameStart.y, nullptr);
                    LineTo(hdcMem, flameLeft.x, flameLeft.y);
                    MoveToEx(hdcMem, flameStart.x, flameStart.y, nullptr);
                    LineTo(hdcMem, flameRight.x, flameRight.y);

                    DeleteObject(hPenFlame);
                    SelectObject(hdcMem, hPenLander);
                }

                // Draw attitude control thrusters
                if (lander.leftThrusterOn) {
                    HPEN hPenRCS = CreatePen(PS_SOLID, 2, RGB(255, 255, 100));
                    SelectObject(hdcMem, hPenRCS);
                    POINT rcsStart = transformPoint(8, -6);
                    POINT rcsEnd = transformPoint(11, -6);
                    MoveToEx(hdcMem, rcsStart.x, rcsStart.y, nullptr);
                    LineTo(hdcMem, rcsEnd.x, rcsEnd.y);
                    DeleteObject(hPenRCS);
                    SelectObject(hdcMem, hPenLander);
                }
                if (lander.rightThrusterOn) {
                    HPEN hPenRCS = CreatePen(PS_SOLID, 2, RGB(255, 255, 100));
                    SelectObject(hdcMem, hPenRCS);
                    POINT rcsStart = transformPoint(-8, -6);
                    POINT rcsEnd = transformPoint(-11, -6);
                    MoveToEx(hdcMem, rcsStart.x, rcsStart.y, nullptr);
                    LineTo(hdcMem, rcsEnd.x, rcsEnd.y);
                    DeleteObject(hPenRCS);
                    SelectObject(hdcMem, hPenLander);
                }

                SelectObject(hdcMem, hOldPen);
                DeleteObject(hPenLander);
            }

            // Draw HUD
            SetTextColor(hdcMem, RGB(255, 255, 255));
            SetBkMode(hdcMem, TRANSPARENT);

            HFONT hFont = CreateFont(16, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                                     DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                     CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Courier New");
            HFONT hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            wchar_t buffer[256];
            StringCchPrintf(buffer, 256, L"Score: %d", score);
            TextOut(hdcMem, 10, 10, buffer, wcslen(buffer));

            StringCchPrintf(buffer, 256, L"Level: %d", level);
            TextOut(hdcMem, 10, 30, buffer, wcslen(buffer));

            StringCchPrintf(buffer, 256, L"Lives: %d", lives);
            TextOut(hdcMem, 10, 50, buffer, wcslen(buffer));

            StringCchPrintf(buffer, 256, L"Fuel: %.1f", lander.fuel);
            TextOut(hdcMem, 10, 70, buffer, wcslen(buffer));

            StringCchPrintf(buffer, 256, L"Velocity: %.2f", lander.vel.length());
            TextOut(hdcMem, 10, 90, buffer, wcslen(buffer));

            // Velocity indicator
            if (lander.vel.length() > settings.safeLandingSpeed) {
                SetTextColor(hdcMem, RGB(255, 0, 0));
                TextOut(hdcMem, 150, 90, L"TOO FAST!", 9);
                SetTextColor(hdcMem, RGB(255, 255, 255));
            }

            // State messages
            if (gameState == GameState::LANDING_SUCCESS) {
                HFONT hBigFont = CreateFont(36, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
                                           DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                           CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
                SelectObject(hdcMem, hBigFont);
                SetTextColor(hdcMem, RGB(0, 255, 0));

                RECT msgRect = {0, WINDOW_HEIGHT / 2 - 50, WINDOW_WIDTH, WINDOW_HEIGHT / 2 + 50};
                DrawText(hdcMem, L"LANDING SUCCESSFUL!", -1, &msgRect,
                        DT_CENTER | DT_VCENTER | DT_SINGLELINE);

                SelectObject(hdcMem, hFont);
                DeleteObject(hBigFont);
                SetTextColor(hdcMem, RGB(255, 255, 255));
            } else if (gameState == GameState::CRASHED) {
                HFONT hBigFont = CreateFont(36, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
                                           DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                           CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
                SelectObject(hdcMem, hBigFont);
                SetTextColor(hdcMem, RGB(255, 0, 0));

                RECT msgRect = {0, WINDOW_HEIGHT / 2 - 50, WINDOW_WIDTH, WINDOW_HEIGHT / 2 + 50};
                DrawText(hdcMem, L"CRASHED!", -1, &msgRect,
                        DT_CENTER | DT_VCENTER | DT_SINGLELINE);

                SelectObject(hdcMem, hFont);
                DeleteObject(hBigFont);
                SetTextColor(hdcMem, RGB(255, 255, 255));
            }

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);
            break;
        }

        case GameState::GAME_OVER: {
            SetTextColor(hdcMem, RGB(255, 255, 255));
            SetBkMode(hdcMem, TRANSPARENT);

            HFONT hFont = CreateFont(48, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
                                     DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                     CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            HFONT hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            RECT titleRect = {0, 150, WINDOW_WIDTH, 200};
            DrawText(hdcMem, L"GAME OVER", -1, &titleRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);

            hFont = CreateFont(24, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                              DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                              CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            wchar_t buffer[128];
            StringCchPrintf(buffer, 128, L"Final Score: %d", score);
            RECT scoreRect = {0, 250, WINDOW_WIDTH, 280};
            DrawText(hdcMem, buffer, -1, &scoreRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            StringCchPrintf(buffer, 128, L"Level Reached: %d", level);
            RECT levelRect = {0, 290, WINDOW_WIDTH, 320};
            DrawText(hdcMem, buffer, -1, &levelRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            RECT instructRect = {0, 380, WINDOW_WIDTH, 410};
            DrawText(hdcMem, L"Press SPACE to play again", -1, &instructRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);
            break;
        }

        case GameState::ENTER_NAME: {
            SetTextColor(hdcMem, RGB(255, 255, 255));
            SetBkMode(hdcMem, TRANSPARENT);

            HFONT hFont = CreateFont(36, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
                                     DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                     CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            HFONT hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            RECT titleRect = {0, 150, WINDOW_WIDTH, 200};
            DrawText(hdcMem, L"HIGH SCORE!", -1, &titleRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);

            hFont = CreateFont(20, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                              DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                              CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            RECT promptRect = {0, 250, WINDOW_WIDTH, 280};
            DrawText(hdcMem, L"Enter your name:", -1, &promptRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            // Draw name input box with dark background
            RECT nameRect = {WINDOW_WIDTH / 2 - 100, 300, WINDOW_WIDTH / 2 + 100, 340};

            // Fill background with dark color
            HBRUSH hBrushInput = CreateSolidBrush(RGB(20, 20, 40));
            FillRect(hdcMem, &nameRect, hBrushInput);
            DeleteObject(hBrushInput);

            // Draw border
            HPEN hPenBorder = CreatePen(PS_SOLID, 2, RGB(0, 255, 0));
            HPEN hOldPen = (HPEN)SelectObject(hdcMem, hPenBorder);
            SelectObject(hdcMem, GetStockObject(NULL_BRUSH));
            Rectangle(hdcMem, nameRect.left, nameRect.top, nameRect.right, nameRect.bottom);
            SelectObject(hdcMem, hOldPen);
            DeleteObject(hPenBorder);

            // Draw text in bright green
            SetTextColor(hdcMem, RGB(0, 255, 0));
            DrawText(hdcMem, playerName, -1, &nameRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            // Draw cursor blink
            static int cursorBlink = 0;
            cursorBlink = (cursorBlink + 1) % 60;
            if (cursorBlink < 30 && nameLength < 20) {
                SIZE textSize;
                HDC hdcTemp = GetDC(nullptr);
                SelectObject(hdcTemp, hFont);
                GetTextExtentPoint32(hdcTemp, playerName, nameLength, &textSize);
                ReleaseDC(nullptr, hdcTemp);

                int cursorX = (WINDOW_WIDTH / 2) + (textSize.cx / 2) + 2;
                MoveToEx(hdcMem, cursorX, nameRect.top + 10, nullptr);
                LineTo(hdcMem, cursorX, nameRect.bottom - 10);
            }

            SetTextColor(hdcMem, RGB(255, 255, 255));
            RECT instructRect = {0, 380, WINDOW_WIDTH, 410};
            DrawText(hdcMem, L"Press ENTER when done", -1, &instructRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);
            break;
        }

        case GameState::HIGH_SCORES: {
            SetTextColor(hdcMem, RGB(255, 255, 255));
            SetBkMode(hdcMem, TRANSPARENT);

            HFONT hFont = CreateFont(36, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
                                     DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                     CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            HFONT hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            RECT titleRect = {0, 50, WINDOW_WIDTH, 100};
            DrawText(hdcMem, L"HIGH SCORES", -1, &titleRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);

            hFont = CreateFont(20, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                              DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                              CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Courier New");
            hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            int y = 130;
            wchar_t buffer[256];
            for (int i = 0; i < MAX_HIGH_SCORES; i++) {
                if (highScores[i].score > 0) {
                    StringCchPrintf(buffer, 256, L"%2d. %-20s %6d  Lvl %2d",
                                   i + 1, highScores[i].name, highScores[i].score, highScores[i].level);
                    TextOut(hdcMem, 100, y, buffer, wcslen(buffer));
                } else {
                    StringCchPrintf(buffer, 256, L"%2d. ---", i + 1);
                    TextOut(hdcMem, 100, y, buffer, wcslen(buffer));
                }
                y += 35;
            }

            RECT instructRect = {0, 520, WINDOW_WIDTH, 550};
            DrawText(hdcMem, L"Press ESC to return", -1, &instructRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);
            break;
        }

        case GameState::CONFIRM_QUIT: {
            // Draw semi-transparent overlay
            for (int oy = 0; oy < WINDOW_HEIGHT; oy += 2) {
                for (int ox = 0; ox < WINDOW_WIDTH; ox += 2) {
                    SetPixel(hdcMem, ox, oy, RGB(0, 0, 0));
                }
            }

            SetTextColor(hdcMem, RGB(255, 255, 255));
            SetBkMode(hdcMem, TRANSPARENT);

            // Draw dialog box background
            RECT dialogRect = {WINDOW_WIDTH / 2 - 180, WINDOW_HEIGHT / 2 - 80,
                              WINDOW_WIDTH / 2 + 180, WINDOW_HEIGHT / 2 + 80};
            HBRUSH hBrushDialog = CreateSolidBrush(RGB(20, 20, 40));
            FillRect(hdcMem, &dialogRect, hBrushDialog);
            DeleteObject(hBrushDialog);

            // Draw border
            HPEN hPenBorder = CreatePen(PS_SOLID, 3, RGB(255, 200, 0));
            HPEN hOldPen = (HPEN)SelectObject(hdcMem, hPenBorder);
            SelectObject(hdcMem, GetStockObject(NULL_BRUSH));
            Rectangle(hdcMem, dialogRect.left, dialogRect.top, dialogRect.right, dialogRect.bottom);
            SelectObject(hdcMem, hOldPen);
            DeleteObject(hPenBorder);

            // Title
            HFONT hFont = CreateFont(28, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
                                     DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                     CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            HFONT hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            SetTextColor(hdcMem, RGB(255, 200, 0));
            RECT titleRect = {dialogRect.left, dialogRect.top + 15, dialogRect.right, dialogRect.top + 50};
            if (confirmMode == ConfirmMode::QUIT) {
                DrawText(hdcMem, L"QUIT GAME?", -1, &titleRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
            } else {
                DrawText(hdcMem, L"RESTART GAME?", -1, &titleRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
            }

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);

            // Options
            hFont = CreateFont(20, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                              DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                              CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            SetTextColor(hdcMem, RGB(255, 255, 255));
            RECT option1Rect = {dialogRect.left, dialogRect.top + 60, dialogRect.right, dialogRect.top + 85};
            RECT option2Rect = {dialogRect.left, dialogRect.top + 90, dialogRect.right, dialogRect.top + 115};
            RECT option3Rect = {dialogRect.left, dialogRect.top + 120, dialogRect.right, dialogRect.top + 145};

            if (confirmMode == ConfirmMode::QUIT) {
                DrawText(hdcMem, L"Q - Quit to Desktop", -1, &option1Rect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
                DrawText(hdcMem, L"R - Restart Game", -1, &option2Rect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
            } else {
                DrawText(hdcMem, L"R - Restart Game", -1, &option1Rect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
                DrawText(hdcMem, L"Q - Quit to Desktop", -1, &option2Rect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
            }
            DrawText(hdcMem, L"ESC - Cancel", -1, &option3Rect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);
            break;
        }

        case GameState::SETTINGS: {
            SetTextColor(hdcMem, RGB(255, 255, 255));
            SetBkMode(hdcMem, TRANSPARENT);

            // Title
            HFONT hFont = CreateFont(36, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
                                     DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                     CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            HFONT hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            SetTextColor(hdcMem, RGB(255, 200, 0));
            RECT titleRect = {0, 50, WINDOW_WIDTH, 100};
            DrawText(hdcMem, L"SETTINGS", -1, &titleRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);

            // Settings options
            hFont = CreateFont(22, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                              DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                              CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Courier New");
            hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            const wchar_t* settingNames[] = {
                L"Gravity",
                L"Thrust Power",
                L"Side Thrust",
                L"Initial Fuel",
                L"Safe Landing Speed"
            };

            float* settingValues[] = {
                &settings.gravity,
                &settings.thrustPower,
                &settings.sideThrustPower,
                &settings.initialFuel,
                &settings.safeLandingSpeed
            };

            int y = 140;
            wchar_t buffer[128];
            for (int i = 0; i < 5; i++) {
                // Highlight selected option
                if (i == settings.selectedOption) {
                    SetTextColor(hdcMem, RGB(0, 255, 0));
                    StringCchPrintf(buffer, 128, L"> %-18s: %8.3f <", settingNames[i], *settingValues[i]);
                } else {
                    SetTextColor(hdcMem, RGB(200, 200, 200));
                    StringCchPrintf(buffer, 128, L"  %-18s: %8.3f", settingNames[i], *settingValues[i]);
                }

                RECT optRect = {100, y, WINDOW_WIDTH - 100, y + 30};
                DrawText(hdcMem, buffer, -1, &optRect, DT_LEFT | DT_VCENTER | DT_SINGLELINE);
                y += 40;
            }

            // Instructions
            y += 30;
            SetTextColor(hdcMem, RGB(150, 150, 150));
            HFONT hSmallFont = CreateFont(18, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                                          DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                          CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            SelectObject(hdcMem, hSmallFont);

            RECT instr1 = {0, y, WINDOW_WIDTH, y + 25};
            DrawText(hdcMem, L"UP/DOWN - Select option", -1, &instr1, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
            y += 25;
            RECT instr2 = {0, y, WINDOW_WIDTH, y + 25};
            DrawText(hdcMem, L"LEFT/RIGHT - Adjust value", -1, &instr2, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
            y += 25;
            RECT instr3 = {0, y, WINDOW_WIDTH, y + 25};
            DrawText(hdcMem, L"R - Reset to defaults", -1, &instr3, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
            y += 25;
            RECT instr4 = {0, y, WINDOW_WIDTH, y + 25};
            DrawText(hdcMem, L"ESC - Return to menu (auto-saves)", -1, &instr4, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hSmallFont);
            DeleteObject(hFont);
            break;
        }

        default:
            break;
    }

    // Copy back buffer to screen
    BitBlt(hdc, 0, 0, WINDOW_WIDTH, WINDOW_HEIGHT, hdcMem, 0, 0, SRCCOPY);
}

// ============================================================================
// High Score Functions
// ============================================================================

/**
 * @brief Check if score qualifies for high score list
 */
bool IsHighScore(int newScore) {
    if (highScores.empty()) return true;
    return newScore > highScores[MAX_HIGH_SCORES - 1].score;
}

/**
 * @brief Update high score list with new score
 */
void UpdateHighScores(int newScore, int newLevel) {
    HighScore newEntry;
    newEntry.score = newScore;
    newEntry.level = newLevel;
    StringCchCopy(newEntry.name, 32, playerName);

    // Insert into sorted position
    bool inserted = false;
    for (int i = 0; i < MAX_HIGH_SCORES; i++) {
        if (newScore > highScores[i].score) {
            // Shift down
            for (int j = MAX_HIGH_SCORES - 1; j > i; j--) {
                highScores[j] = highScores[j - 1];
            }
            highScores[i] = newEntry;
            inserted = true;
            break;
        }
    }

    if (!inserted && highScores.size() < static_cast<size_t>(MAX_HIGH_SCORES)) {
        highScores.push_back(newEntry);
    }

    SaveHighScores();
}

/**
 * @brief Save high scores to file
 */
void SaveHighScores() {
    std::ofstream file(HIGH_SCORE_FILE, std::ios::binary);
    if (file.is_open()) {
        for (const auto& score : highScores) {
            file.write(reinterpret_cast<const char*>(&score), sizeof(HighScore));
        }
        file.close();
    }
}

/**
 * @brief Load high scores from file
 */
void LoadHighScores() {
    std::ifstream file(HIGH_SCORE_FILE, std::ios::binary);
    if (file.is_open()) {
        highScores.clear();
        HighScore score;
        while (file.read(reinterpret_cast<char*>(&score), sizeof(HighScore))) {
            highScores.push_back(score);
        }
        file.close();
    }

    // Fill remaining slots with empty scores
    while (highScores.size() < static_cast<size_t>(MAX_HIGH_SCORES)) {
        HighScore emptyScore;
        highScores.push_back(emptyScore);
    }
}

// ============================================================================
// Settings Functions
// ============================================================================

/**
 * @brief Save settings to INI file
 */
void SaveSettings() {
    std::wofstream file(SETTINGS_FILE);
    if (file.is_open()) {
        file << L"[Settings]\n";
        file << L"gravity=" << std::fixed << std::setprecision(3) << settings.gravity << L"\n";
        file << L"thrustPower=" << std::fixed << std::setprecision(3) << settings.thrustPower << L"\n";
        file << L"sideThrustPower=" << std::fixed << std::setprecision(3) << settings.sideThrustPower << L"\n";
        file << L"initialFuel=" << std::fixed << std::setprecision(1) << settings.initialFuel << L"\n";
        file << L"safeLandingSpeed=" << std::fixed << std::setprecision(2) << settings.safeLandingSpeed << L"\n";
        file.close();
    }
}

/**
 * @brief Load settings from INI file
 */
void LoadSettings() {
    std::wifstream file(SETTINGS_FILE);
    if (file.is_open()) {
        std::wstring line;
        while (std::getline(file, line)) {
            // Skip section headers and empty lines
            if (line.empty() || line[0] == L'[') continue;

            // Parse key=value pairs
            size_t eqPos = line.find(L'=');
            if (eqPos != std::wstring::npos) {
                std::wstring key = line.substr(0, eqPos);
                std::wstring value = line.substr(eqPos + 1);

                if (key == L"gravity") {
                    settings.gravity = std::stof(value);
                } else if (key == L"thrustPower") {
                    settings.thrustPower = std::stof(value);
                } else if (key == L"sideThrustPower") {
                    settings.sideThrustPower = std::stof(value);
                } else if (key == L"initialFuel") {
                    settings.initialFuel = std::stof(value);
                } else if (key == L"safeLandingSpeed") {
                    settings.safeLandingSpeed = std::stof(value);
                }
            }
        }
        file.close();
    }
}

/**
 * @brief Reset settings to defaults
 */
void ResetSettings() {
    settings.gravity = 0.05f;
    settings.thrustPower = 0.12f;
    settings.sideThrustPower = 0.08f;
    settings.initialFuel = 100.0f;
    settings.safeLandingSpeed = 1.5f;
    SaveSettings();
}

// ============================================================================
// Sound Functions
// ============================================================================

/**
 * @brief Generate realistic rocket engine sound buffer
 * Creates powerful rocket thrust with deep bass rumble and white noise
 */
void GenerateRocketSound(short* buffer, int samples) {
    static float filterState = 0.0f;
    static float deepFilterState = 0.0f;
    const float filterAlpha = 0.15f;      // Low-pass filter
    const float deepFilterAlpha = 0.05f;   // Extra deep bass filter

    for (int i = 0; i < samples; i++) {
        // Generate white noise
        float noise = static_cast<float>(rand() - RAND_MAX / 2) / (RAND_MAX / 2);

        // Apply two stages of low-pass filtering for deeper rumble
        filterState = filterState * (1.0f - filterAlpha) + noise * filterAlpha;
        deepFilterState = deepFilterState * (1.0f - deepFilterAlpha) + filterState * deepFilterAlpha;

        // Add deep bass rumble (sub-bass frequency ~30-50 Hz)
        float bassPhase = static_cast<float>(i) * 40.0f / 22050.0f;
        float deepBass = std::sin(bassPhase * 6.28318f) * 0.4f;

        // Add mid-frequency engine roar
        float midPhase = static_cast<float>(i) * 120.0f / 22050.0f;
        float midRoar = std::sin(midPhase * 6.28318f) * 0.2f;

        // Combine all elements for powerful rocket sound
        // 50% deep filtered noise, 30% sub-bass, 20% mid roar
        float sample = (deepFilterState * 0.5f + deepBass + midRoar) * 32000.0f;

        // Clamp to 16-bit range
        if (sample > 32767.0f) sample = 32767.0f;
        if (sample < -32768.0f) sample = -32768.0f;

        buffer[i] = static_cast<short>(sample);
    }
}

/**
 * @brief Initialize audio system
 */
bool InitAudio() {
    if (soundInitialized) return true;

    WAVEFORMATEX wfx = {};
    wfx.wFormatTag = WAVE_FORMAT_PCM;
    wfx.nChannels = 1;
    wfx.nSamplesPerSec = 22050;
    wfx.wBitsPerSample = 16;
    wfx.nBlockAlign = wfx.nChannels * wfx.wBitsPerSample / 8;
    wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;

    if (waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL) != MMSYSERR_NOERROR) {
        return false;
    }

    soundInitialized = true;
    return true;
}

/**
 * @brief Clean up audio system
 */
void CleanupAudio() {
    if (hWaveOut) {
        waveOutReset(hWaveOut);
        waveOutClose(hWaveOut);
        hWaveOut = nullptr;
    }
    soundInitialized = false;
}

/**
 * @brief Thread function for continuous thrust sound
 */
DWORD WINAPI ThrustSoundThreadProc(LPVOID lpParam) {
    (void)lpParam;

    if (!InitAudio()) {
        return 1;
    }

    const int bufferSize = 4410;  // 0.2 seconds at 22050 Hz
    short* buffer1 = new short[bufferSize];
    short* buffer2 = new short[bufferSize];

    // Initialize headers
    ZeroMemory(&waveHeader[0], sizeof(WAVEHDR));
    ZeroMemory(&waveHeader[1], sizeof(WAVEHDR));

    waveHeader[0].lpData = reinterpret_cast<LPSTR>(buffer1);
    waveHeader[0].dwBufferLength = bufferSize * sizeof(short);
    waveHeader[1].lpData = reinterpret_cast<LPSTR>(buffer2);
    waveHeader[1].dwBufferLength = bufferSize * sizeof(short);

    // Generate initial sound data for both buffers
    GenerateRocketSound(buffer1, bufferSize);
    GenerateRocketSound(buffer2, bufferSize);

    // Prepare and queue both buffers
    waveOutPrepareHeader(hWaveOut, &waveHeader[0], sizeof(WAVEHDR));
    waveOutPrepareHeader(hWaveOut, &waveHeader[1], sizeof(WAVEHDR));
    waveOutWrite(hWaveOut, &waveHeader[0], sizeof(WAVEHDR));
    waveOutWrite(hWaveOut, &waveHeader[1], sizeof(WAVEHDR));

    int currentBuffer = 0;

    while (thrustSoundActive) {
        WAVEHDR* pHdr = &waveHeader[currentBuffer];

        // Wait for current buffer to finish playing
        while (!(pHdr->dwFlags & WHDR_DONE) && thrustSoundActive) {
            Sleep(10);
        }

        if (!thrustSoundActive) break;

        // Generate new sound data
        short* buf = reinterpret_cast<short*>(pHdr->lpData);
        GenerateRocketSound(buf, bufferSize);

        // Write buffer again
        waveOutWrite(hWaveOut, pHdr, sizeof(WAVEHDR));

        currentBuffer = 1 - currentBuffer;  // Swap buffers
    }

    // Cleanup
    waveOutReset(hWaveOut);
    waveOutUnprepareHeader(hWaveOut, &waveHeader[0], sizeof(WAVEHDR));
    waveOutUnprepareHeader(hWaveOut, &waveHeader[1], sizeof(WAVEHDR));

    delete[] buffer1;
    delete[] buffer2;

    return 0;
}

/**
 * @brief Start continuous thrust sound
 */
void PlaySound_Thrust() {
    if (!thrustSoundActive) {
        thrustSoundActive = true;
        thrustSoundThread = CreateThread(nullptr, 0, ThrustSoundThreadProc, nullptr, 0, nullptr);
    }
}

/**
 * @brief Stop continuous thrust sound
 */
void StopSound_Thrust() {
    if (thrustSoundActive) {
        thrustSoundActive = false;
        if (thrustSoundThread) {
            WaitForSingleObject(thrustSoundThread, 1000);
            CloseHandle(thrustSoundThread);
            thrustSoundThread = nullptr;
        }
    }
}

/**
 * @brief Generate EPIC arcade explosion sound - Classic KABOOM!
 * Inspired by Asteroids, Defender, and Robotron explosions
 */
void GenerateExplosionSound(short* buffer, int samples) {
    static float filterState1 = 0.0f;
    static float filterState2 = 0.0f;

    for (int i = 0; i < samples; i++) {
        float t = static_cast<float>(i) / samples;

        // Generate white noise for explosion texture
        float noise = static_cast<float>(rand() - RAND_MAX / 2) / (RAND_MAX / 2);

        // === PHASE 1: INITIAL IMPACT (0-5%) - The "KA-" ===
        float impact = 0.0f;
        if (t < 0.05f) {
            float impactT = t / 0.05f;
            // Massive square wave burst
            float squareWave = (std::sin(impactT * 6.28318f * 200.0f) > 0.0f) ? 1.0f : -1.0f;
            // Add some harmonics for crunch
            squareWave += (std::sin(impactT * 6.28318f * 400.0f) > 0.0f) ? 0.5f : -0.5f;
            impact = squareWave * (1.0f - impactT) * 2.0f;
        }

        // === PHASE 2: PRIMARY BOOM (5-40%) - The "-BOOM" ===
        float boom = 0.0f;
        if (t >= 0.05f && t < 0.4f) {
            float boomT = (t - 0.05f) / 0.35f;
            float boomEnv = std::exp(-boomT * 4.0f);

            // Deep descending sweep (the signature arcade sound)
            float startFreq = 600.0f;
            float endFreq = 30.0f;
            float freq = startFreq * std::pow(endFreq / startFreq, boomT);
            boom = std::sin(i * freq * 6.28318f / 22050.0f) * boomEnv * 1.5f;

            // Add second harmonic for richness
            float freq2 = freq * 1.5f;
            boom += std::sin(i * freq2 * 6.28318f / 22050.0f) * boomEnv * 0.5f;
        }

        // === PHASE 3: SECONDARY EXPLOSIONS (10-60%) ===
        float secondary = 0.0f;
        if (t >= 0.1f && t < 0.6f) {
            float secT = (t - 0.1f) / 0.5f;

            // Multiple smaller "pops" at different rates
            float pop1 = std::sin(i * (400.0f - secT * 300.0f) * 6.28318f / 22050.0f);
            float pop2 = std::sin(i * (300.0f - secT * 200.0f) * 6.28318f / 22050.0f);

            // Gated bursts for that classic arcade crackle
            int burstGate = (i / 300) % 5;
            float gate = (burstGate < 3) ? 1.0f : 0.3f;

            secondary = (pop1 * 0.4f + pop2 * 0.3f) * std::exp(-secT * 3.0f) * gate;
        }

        // === PHASE 4: RUMBLING DECAY (20-100%) ===
        float rumble = 0.0f;
        if (t >= 0.2f) {
            float rumbleT = (t - 0.2f) / 0.8f;
            float rumbleEnv = std::exp(-rumbleT * 2.5f);

            // Low frequency rumble
            float rumbleFreq = 40.0f - rumbleT * 20.0f;
            rumble = std::sin(i * rumbleFreq * 6.28318f / 22050.0f) * rumbleEnv * 0.8f;

            // Add filtered noise for debris/crackle texture
            filterState1 = filterState1 * 0.85f + noise * 0.15f;
            rumble += filterState1 * rumbleEnv * 0.6f;
        }

        // === PHASE 5: NOISE TEXTURE (throughout) ===
        // Filtered noise that decays over time
        float noiseEnv = std::exp(-t * 4.0f);
        filterState2 = filterState2 * 0.7f + noise * 0.3f;
        float textureNoise = filterState2 * noiseEnv * 0.4f;

        // === FINAL MIX ===
        float sample = (impact * 1.2f + boom + secondary + rumble + textureNoise) * 28000.0f;

        // Soft clipping for that warm arcade sound
        if (sample > 30000.0f) sample = 30000.0f + (sample - 30000.0f) * 0.3f;
        if (sample < -30000.0f) sample = -30000.0f + (sample + 30000.0f) * 0.3f;

        // Hard clamp
        if (sample > 32767.0f) sample = 32767.0f;
        if (sample < -32768.0f) sample = -32768.0f;

        buffer[i] = static_cast<short>(sample);
    }
}

/**
 * @brief Play crash sound effect with realistic explosion
 */
void PlaySound_Crash() {
    if (!InitAudio()) {
        Beep(100, 300);  // Fallback
        return;
    }

    const int bufferSize = 22050;  // 1 second explosion
    short* explosionBuffer = new short[bufferSize];
    GenerateExplosionSound(explosionBuffer, bufferSize);

    WAVEHDR hdr = {};
    hdr.lpData = reinterpret_cast<LPSTR>(explosionBuffer);
    hdr.dwBufferLength = bufferSize * sizeof(short);

    waveOutPrepareHeader(hWaveOut, &hdr, sizeof(WAVEHDR));
    waveOutWrite(hWaveOut, &hdr, sizeof(WAVEHDR));

    // Wait for sound to finish
    while (!(hdr.dwFlags & WHDR_DONE)) {
        Sleep(10);
    }

    waveOutUnprepareHeader(hWaveOut, &hdr, sizeof(WAVEHDR));
    delete[] explosionBuffer;
}

/**
 * @brief Play landing sound effect
 */
void PlaySound_Landing() {
    Beep(800, 100);
    Beep(600, 100);
    Beep(400, 200);
}

/**
 * @brief Play menu selection sound
 */
void PlaySound_MenuSelect() {
    Beep(440, 100);
}

/**
 * @brief Thread function for space frontier intro sound
 * Cinematic space western theme - mysterious, epic, adventurous!
 */
DWORD WINAPI IntroSoundThreadProc(LPVOID lpParam) {
    (void)lpParam;

    // SPACE FRONTIER THEME - Cinematic & Mysterious (~4 seconds)

    // Part 1: Deep space atmosphere - mysterious opening
    Beep(110, 400);   // A2 - Deep rumbling bass
    Sleep(50);
    Beep(165, 300);   // E3 - Rising from the void
    Beep(220, 250);   // A3 - Establishing tone
    Sleep(100);

    // Part 2: The frontier call - western-inspired melody
    Beep(330, 200);   // E4 - First frontier note
    Beep(294, 150);   // D4 - Drop
    Beep(330, 200);   // E4 - Rise
    Beep(440, 350);   // A4 - The call!
    Sleep(80);

    // Part 3: Space adventure motif - heroic but lonely
    Beep(392, 180);   // G4
    Beep(330, 180);   // E4
    Beep(294, 180);   // D4
    Beep(262, 300);   // C4 - Settling
    Sleep(60);

    // Part 4: Epic conclusion - the final frontier
    Beep(196, 150);   // G3 - Bass foundation
    Beep(262, 150);   // C4 - Building
    Beep(330, 150);   // E4
    Beep(392, 200);   // G4
    Beep(523, 400);   // C5 - Triumphant peak!
    Sleep(100);

    // Part 5: Mysterious echo - into the unknown
    Beep(392, 250);   // G4 - Echo 1
    Sleep(50);
    Beep(330, 250);   // E4 - Echo 2
    Sleep(50);
    Beep(262, 400);   // C4 - Final resonance - the journey begins

    return 0;
}

/**
 * @brief Play space frontier intro sound in background
 */
void PlaySound_Intro() {
    // Play in background thread so it doesn't block startup
    HANDLE hThread = CreateThread(nullptr, 0, IntroSoundThreadProc, nullptr, 0, nullptr);
    if (hThread) {
        CloseHandle(hThread);  // We don't need to wait for it
    }
}

// ============================================================================
// Utility Functions
// ============================================================================

/**
 * @brief Linear interpolation
 */
float Lerp(float a, float b, float t) {
    return a + (b - a) * t;
}

/**
 * @brief Clamp value between min and max
 */
float Clamp(float value, float min, float max) {
    if (value < min) return min;
    if (value > max) return max;
    return value;
}

// ============================================================================
// Windows Message Handling
// ============================================================================

/**
 * @brief Window procedure callback
 */
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    switch (uMsg) {
        case WM_CREATE:
            LoadSettings();      // Load game settings from INI file
            LoadHighScores();
            InitStars();
            InitBackgroundLanders();  // Initialize title screen animation
            SetTimer(hwnd, 1, TARGET_FRAME_TIME, nullptr);
            PlaySound_Intro();  // Play space frontier intro sound
            return 0;

        case WM_DESTROY:
            StopSound_Thrust();  // Clean up sound thread
            CleanupAudio();      // Clean up audio system
            SaveHighScores();
            PostQuitMessage(0);
            return 0;

        case WM_TIMER:
            if (gameState == GameState::PLAYING ||
                gameState == GameState::LANDING_SUCCESS ||
                gameState == GameState::CRASHED) {
                UpdateGame();
            }
            InvalidateRect(hwnd, nullptr, FALSE);
            return 0;

        case WM_PAINT: {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hwnd, &ps);
            RenderGame(hdc);
            EndPaint(hwnd, &ps);
            return 0;
        }

        case WM_KEYDOWN:
            keys[wParam] = true;

            // Handle game state transitions
            switch (gameState) {
                case GameState::TITLE_SCREEN:
                    if (wParam == VK_SPACE) {
                        InitGame();
                        PlaySound_MenuSelect();
                    } else if (wParam == 'H') {
                        gameState = GameState::HIGH_SCORES;
                        PlaySound_MenuSelect();
                    } else if (wParam == 'S') {
                        gameState = GameState::SETTINGS;
                        PlaySound_MenuSelect();
                    } else if (wParam == 'Q') {
                        PostQuitMessage(0);  // Quit directly from title screen
                    }
                    break;

                case GameState::GAME_OVER:
                    if (wParam == VK_SPACE) {
                        InitGame();
                        PlaySound_MenuSelect();
                    } else if (wParam == 'Q') {
                        PostQuitMessage(0);  // Quit from game over
                    } else if (wParam == 'R') {
                        InitGame();
                        PlaySound_MenuSelect();
                    }
                    break;

                case GameState::HIGH_SCORES:
                    if (wParam == VK_ESCAPE) {
                        gameState = GameState::TITLE_SCREEN;
                        InitBackgroundLanders();  // Reset animation
                        PlaySound_MenuSelect();
                    } else if (wParam == 'Q') {
                        PostQuitMessage(0);  // Quit from high scores
                    }
                    break;

                case GameState::ENTER_NAME:
                    if (wParam == VK_RETURN && nameLength > 0) {
                        UpdateHighScores(score, level);
                        gameState = GameState::HIGH_SCORES;
                        PlaySound_MenuSelect();
                    } else if (wParam == VK_BACK && nameLength > 0) {
                        nameLength--;
                        playerName[nameLength] = L'\0';
                    }
                    break;

                case GameState::PLAYING:
                    if (wParam == VK_ESCAPE) {
                        gameState = GameState::TITLE_SCREEN;
                        InitBackgroundLanders();  // Reset animation
                        StopSound_Thrust();  // Stop any thrust sound
                    } else if (wParam == 'P') {
                        gameState = GameState::PAUSED;
                    } else if (wParam == 'Q') {
                        previousState = gameState;
                        confirmMode = ConfirmMode::QUIT;
                        gameState = GameState::CONFIRM_QUIT;
                        StopSound_Thrust();
                        PlaySound_MenuSelect();
                    } else if (wParam == 'R') {
                        previousState = gameState;
                        confirmMode = ConfirmMode::RESTART;
                        gameState = GameState::CONFIRM_QUIT;
                        StopSound_Thrust();
                        PlaySound_MenuSelect();
                    }
                    break;

                case GameState::PAUSED:
                    if (wParam == 'P' || wParam == VK_ESCAPE) {
                        gameState = GameState::PLAYING;
                    } else if (wParam == 'Q') {
                        previousState = gameState;
                        confirmMode = ConfirmMode::QUIT;
                        gameState = GameState::CONFIRM_QUIT;
                        PlaySound_MenuSelect();
                    } else if (wParam == 'R') {
                        previousState = gameState;
                        confirmMode = ConfirmMode::RESTART;
                        gameState = GameState::CONFIRM_QUIT;
                        PlaySound_MenuSelect();
                    }
                    break;

                case GameState::CONFIRM_QUIT:
                    if (wParam == VK_ESCAPE) {
                        // Cancel - return to previous state
                        gameState = previousState;
                        PlaySound_MenuSelect();
                    } else if (wParam == 'Q') {
                        // Quit to desktop
                        PostQuitMessage(0);
                    } else if (wParam == 'R') {
                        // Restart the game
                        InitGame();
                        PlaySound_MenuSelect();
                    }
                    break;

                case GameState::SETTINGS: {
                    // Setting adjustment values
                    float settingSteps[] = { 0.01f, 0.01f, 0.01f, 10.0f, 0.1f };
                    float settingMins[] = { 0.01f, 0.01f, 0.01f, 10.0f, 0.5f };
                    float settingMaxs[] = { 0.20f, 0.30f, 0.20f, 500.0f, 5.0f };
                    float* settingValues[] = {
                        &settings.gravity,
                        &settings.thrustPower,
                        &settings.sideThrustPower,
                        &settings.initialFuel,
                        &settings.safeLandingSpeed
                    };

                    if (wParam == VK_ESCAPE) {
                        SaveSettings();
                        gameState = GameState::TITLE_SCREEN;
                        InitBackgroundLanders();
                        PlaySound_MenuSelect();
                    } else if (wParam == VK_UP) {
                        settings.selectedOption = (settings.selectedOption - 1 + 5) % 5;
                        PlaySound_MenuSelect();
                    } else if (wParam == VK_DOWN) {
                        settings.selectedOption = (settings.selectedOption + 1) % 5;
                        PlaySound_MenuSelect();
                    } else if (wParam == VK_LEFT) {
                        int opt = settings.selectedOption;
                        *settingValues[opt] -= settingSteps[opt];
                        if (*settingValues[opt] < settingMins[opt]) {
                            *settingValues[opt] = settingMins[opt];
                        }
                        SaveSettings();  // Auto-save on change
                    } else if (wParam == VK_RIGHT) {
                        int opt = settings.selectedOption;
                        *settingValues[opt] += settingSteps[opt];
                        if (*settingValues[opt] > settingMaxs[opt]) {
                            *settingValues[opt] = settingMaxs[opt];
                        }
                        SaveSettings();  // Auto-save on change
                    } else if (wParam == 'R') {
                        ResetSettings();
                        PlaySound_MenuSelect();
                    }
                    break;
                }

                default:
                    break;
            }
            return 0;

        case WM_KEYUP:
            keys[wParam] = false;
            return 0;

        case WM_CHAR:
            if (gameState == GameState::ENTER_NAME) {
                if (wParam >= 32 && wParam < 127 && nameLength < 20) {
                    playerName[nameLength++] = static_cast<wchar_t>(wParam);
                    playerName[nameLength] = L'\0';
                }
            }
            return 0;

        default:
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
}

// ============================================================================
// Main Entry Point
// ============================================================================

/**
 * @brief Application entry point
 */
int WINAPI WinMain(
    _In_ HINSTANCE hInstance,
    _In_opt_ HINSTANCE hPrevInstance,
    _In_ LPSTR lpCmdLine,
    _In_ int nCmdShow
) {
    (void)hPrevInstance;
    (void)lpCmdLine;

    // Register window class
    const wchar_t CLASS_NAME[] = L"LunarLanderClass";

    WNDCLASS wc = {};
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = CLASS_NAME;
    wc.hCursor = LoadCursor(nullptr, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);

    RegisterClass(&wc);

    // Create window
    DWORD dwStyle = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX;
    RECT windowRect = {0, 0, WINDOW_WIDTH, WINDOW_HEIGHT};
    AdjustWindowRect(&windowRect, dwStyle, FALSE);

    int windowWidth = windowRect.right - windowRect.left;
    int windowHeight = windowRect.bottom - windowRect.top;

    HWND hwnd = CreateWindowEx(
        0,
        CLASS_NAME,
        L"Lunar Lander",
        dwStyle,
        CW_USEDEFAULT, CW_USEDEFAULT,
        windowWidth, windowHeight,
        nullptr,
        nullptr,
        hInstance,
        nullptr
    );

    if (hwnd == nullptr) {
        return 0;
    }

    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    // Game loop
    MSG msg = {};
    while (GetMessage(&msg, nullptr, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return static_cast<int>(msg.wParam);
}
