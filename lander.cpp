/**
 * @file lander.cpp
 * @brief Classic lunar lander game for Windows
 * @author Todd Dube
 * @copyright Copyright (c) 2025 Todd Dube
 *
 * A classic lunar lander game with physics simulation, terrain generation,
 * and multiple difficulty levels. Navigate your lander to safe landing zones
 * while managing fuel and velocity.
 */

// ============================================================================
// Platform Configuration and Unicode Setup
// ============================================================================
#ifndef UNICODE
#define UNICODE
#endif
#ifndef _UNICODE
#define _UNICODE
#endif

// ============================================================================
// System and Library Includes
// ============================================================================
#include <windows.h>
#include <windowsx.h>
#include <strsafe.h>
#include <vector>
#include <cmath>
#include <algorithm>
#include <random>
#include <string>
#include <fstream>

// Include version header (generated by build system)
#ifdef _MSC_VER
#include "version.h"
#else
// Fallback for manual compilation
#define LANDER_VERSION_STRING "1.0.0"
#define LANDER_AUTHOR "Todd Dube"
#define LANDER_COPYRIGHT "Copyright (c) 2025 Todd Dube"
#endif

// ============================================================================
// Game Constants
// ============================================================================
constexpr int WINDOW_WIDTH = 800;
constexpr int WINDOW_HEIGHT = 600;
constexpr float GRAVITY = 0.05f;           // Downward acceleration per frame
constexpr float THRUST_POWER = 0.12f;      // Upward acceleration from main thruster
constexpr float SIDE_THRUST_POWER = 0.08f; // Horizontal acceleration from side thrusters
constexpr float MAX_VELOCITY = 15.0f;      // Terminal velocity
constexpr float SAFE_LANDING_SPEED = 1.5f; // Maximum safe landing velocity
constexpr float FUEL_USAGE_MAIN = 0.5f;    // Fuel consumed per frame for main thruster
constexpr float FUEL_USAGE_SIDE = 0.3f;    // Fuel consumed per frame for side thrusters
constexpr float INITIAL_FUEL = 100.0f;     // Starting fuel amount
constexpr int TERRAIN_POINTS = 100;        // Number of terrain vertices
constexpr int MIN_LANDING_PAD_WIDTH = 40;  // Minimum width of landing pad
constexpr int MAX_LANDING_PAD_WIDTH = 80;  // Maximum width of landing pad
constexpr int LANDER_WIDTH = 20;           // Width of lander
constexpr int LANDER_HEIGHT = 20;          // Height of lander
constexpr int MAX_HIGH_SCORES = 10;        // Number of high scores to track
constexpr int STAR_COUNT = 100;            // Number of background stars

// Scoring constants
constexpr int SCORE_BASE_LANDING = 100;    // Base score for successful landing
constexpr int SCORE_FUEL_BONUS = 2;        // Points per unit of remaining fuel
constexpr int SCORE_SPEED_BONUS = 50;      // Bonus for gentle landing
constexpr int SCORE_CENTER_BONUS = 100;    // Bonus for landing in center of pad

// ============================================================================
// Core Data Structures
// ============================================================================

/**
 * @brief 2D vector for position and velocity
 */
struct Vector2 {
    float x{0.0f};
    float y{0.0f};

    constexpr Vector2() = default;
    constexpr Vector2(float _x, float _y) : x(_x), y(_y) {}

    constexpr Vector2 operator+(const Vector2& v) const noexcept {
        return Vector2(x + v.x, y + v.y);
    }

    constexpr Vector2 operator-(const Vector2& v) const noexcept {
        return Vector2(x - v.x, y - v.y);
    }

    constexpr Vector2 operator*(float scalar) const noexcept {
        return Vector2(x * scalar, y * scalar);
    }

    Vector2& operator+=(const Vector2& v) noexcept {
        x += v.x;
        y += v.y;
        return *this;
    }

    float length() const noexcept {
        return std::sqrt(x * x + y * y);
    }
};

/**
 * @brief Lunar lander spacecraft
 */
struct Lander {
    Vector2 pos{WINDOW_WIDTH / 2.0f, 50.0f}; // Current position
    Vector2 vel{0.0f, 0.0f};                 // Current velocity
    float fuel{INITIAL_FUEL};                // Remaining fuel
    float rotation{0.0f};                    // Rotation angle in radians
    bool mainThrusterOn{false};              // Main thruster state
    bool leftThrusterOn{false};              // Left thruster state
    bool rightThrusterOn{false};             // Right thruster state
    bool crashed{false};                     // Crash state
    bool landed{false};                      // Landed state
};

/**
 * @brief Terrain point
 */
struct TerrainPoint {
    int x{0};
    int y{0};
    bool isLandingPad{false};  // True if this segment is a landing pad
};

/**
 * @brief Particle for explosion effects
 */
struct Particle {
    Vector2 pos;
    Vector2 vel;
    int lifetime{0};  // Frames remaining
    int maxLifetime{0};
};

/**
 * @brief Star for background
 */
struct Star {
    int x{0};
    int y{0};
    int brightness{0};  // 0-255
};

/**
 * @brief High score entry
 */
struct HighScore {
    int score{0};
    int level{1};
    wchar_t name[32]{L"---"};
};

/**
 * @brief Game state enumeration
 */
enum class GameState {
    TITLE_SCREEN,
    PLAYING,
    PAUSED,
    LANDING_SUCCESS,
    CRASHED,
    GAME_OVER,
    HIGH_SCORES,
    ENTER_NAME
};

// ============================================================================
// Global Game State
// ============================================================================

// Game objects
Lander lander;
std::vector<TerrainPoint> terrain;
std::vector<Particle> particles;
std::vector<Star> stars;
std::vector<HighScore> highScores(MAX_HIGH_SCORES);

// Game state
GameState gameState = GameState::TITLE_SCREEN;
int score = 0;
int level = 1;
int lives = 3;
int landingPadStart = 0;  // Index of landing pad start in terrain
int landingPadEnd = 0;    // Index of landing pad end in terrain

// Input state
bool keys[256] = {false};

// UI state
wchar_t playerName[32] = L"";
int nameLength = 0;

// Random number generator
std::random_device rd;
std::mt19937 gen(rd());

// High score file path
const wchar_t* HIGH_SCORE_FILE = L"lander_scores.dat";

// Timing
DWORD lastFrameTime = 0;
constexpr DWORD TARGET_FRAME_TIME = 16;  // ~60 FPS

// ============================================================================
// Function Prototypes
// ============================================================================

// Initialization
void InitGame();
void InitStars();
void InitTerrain();
void InitLander();

// Game loop
void UpdateGame();
void RenderGame(HDC hdc);

// Physics
void UpdatePhysics();
void ApplyThrust();
bool CheckTerrainCollision();
bool CheckLandingPadCollision();

// Particles
void SpawnExplosion(const Vector2& pos);
void UpdateParticles();

// High scores
void UpdateHighScores(int newScore, int newLevel);
void SaveHighScores();
void LoadHighScores();
bool IsHighScore(int newScore);

// Sound generation
void PlaySound_Thrust();
void PlaySound_Crash();
void PlaySound_Landing();
void PlaySound_MenuSelect();

// Utility
float Lerp(float a, float b, float t);
float Clamp(float value, float min, float max);

// Windows message handling
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

// ============================================================================
// Initialization Functions
// ============================================================================

/**
 * @brief Initialize new game
 */
void InitGame() {
    score = 0;
    level = 1;
    lives = 3;
    gameState = GameState::PLAYING;

    InitLander();
    InitTerrain();
    InitStars();

    particles.clear();
}

/**
 * @brief Initialize background stars
 */
void InitStars() {
    stars.clear();
    std::uniform_int_distribution<> xDist(0, WINDOW_WIDTH);
    std::uniform_int_distribution<> yDist(0, WINDOW_HEIGHT / 2);
    std::uniform_int_distribution<> brightDist(50, 255);

    for (int i = 0; i < STAR_COUNT; i++) {
        Star star;
        star.x = xDist(gen);
        star.y = yDist(gen);
        star.brightness = brightDist(gen);
        stars.push_back(star);
    }
}

/**
 * @brief Generate random terrain with landing pad
 */
void InitTerrain() {
    terrain.clear();

    // Generate terrain heights
    std::uniform_int_distribution<> heightDist(
        WINDOW_HEIGHT - 200 + (level * 5),  // Terrain gets higher each level
        WINDOW_HEIGHT - 50
    );
    std::uniform_int_distribution<> roughnessDist(
        -20 - (level * 2),  // Terrain gets rougher each level
        20 + (level * 2)
    );

    int segmentWidth = WINDOW_WIDTH / TERRAIN_POINTS;
    int currentHeight = heightDist(gen);

    // Choose random location for landing pad
    std::uniform_int_distribution<> padPosDist(
        TERRAIN_POINTS / 4,
        (TERRAIN_POINTS * 3) / 4
    );
    int padPosition = padPosDist(gen);
    int padWidth = (MIN_LANDING_PAD_WIDTH + MAX_LANDING_PAD_WIDTH) / (2 * segmentWidth);

    landingPadStart = padPosition;
    landingPadEnd = padPosition + padWidth;

    // Generate terrain points
    for (int i = 0; i < TERRAIN_POINTS; i++) {
        TerrainPoint point;
        point.x = i * segmentWidth;

        // Landing pad is flat
        if (i >= landingPadStart && i < landingPadEnd) {
            point.y = currentHeight;
            point.isLandingPad = true;
        } else {
            currentHeight += roughnessDist(gen);
            currentHeight = static_cast<int>(Clamp(
                static_cast<float>(currentHeight),
                static_cast<float>(WINDOW_HEIGHT - 200),
                static_cast<float>(WINDOW_HEIGHT - 50)
            ));
            point.y = currentHeight;
            point.isLandingPad = false;
        }

        terrain.push_back(point);
    }

    // Ensure last point connects to edge
    terrain.back().x = WINDOW_WIDTH;
}

/**
 * @brief Initialize lander at start position
 */
void InitLander() {
    lander.pos = Vector2(WINDOW_WIDTH / 2.0f, 50.0f);
    lander.vel = Vector2(0.0f, 0.0f);
    lander.fuel = INITIAL_FUEL + (level * 10.0f);  // Bonus fuel each level
    lander.rotation = 0.0f;
    lander.mainThrusterOn = false;
    lander.leftThrusterOn = false;
    lander.rightThrusterOn = false;
    lander.crashed = false;
    lander.landed = false;
}

// ============================================================================
// Game Loop Functions
// ============================================================================

/**
 * @brief Update game state
 */
void UpdateGame() {
    switch (gameState) {
        case GameState::PLAYING:
            ApplyThrust();
            UpdatePhysics();
            UpdateParticles();

            // Check for crash or landing
            if (CheckTerrainCollision()) {
                if (CheckLandingPadCollision() &&
                    lander.vel.length() < SAFE_LANDING_SPEED &&
                    std::abs(lander.rotation) < 0.2f) {
                    // Successful landing
                    lander.landed = true;
                    lander.vel = Vector2(0.0f, 0.0f);
                    gameState = GameState::LANDING_SUCCESS;
                    PlaySound_Landing();

                    // Calculate score
                    int landingScore = SCORE_BASE_LANDING;
                    landingScore += static_cast<int>(lander.fuel) * SCORE_FUEL_BONUS;
                    if (lander.vel.length() < SAFE_LANDING_SPEED / 2.0f) {
                        landingScore += SCORE_SPEED_BONUS;
                    }
                    // Check if landed in center of pad
                    float padCenterX = (terrain[landingPadStart].x + terrain[landingPadEnd].x) / 2.0f;
                    if (std::abs(lander.pos.x - padCenterX) < 20.0f) {
                        landingScore += SCORE_CENTER_BONUS;
                    }
                    score += landingScore * level;  // Multiply by level
                } else {
                    // Crash
                    lander.crashed = true;
                    lander.vel = Vector2(0.0f, 0.0f);
                    gameState = GameState::CRASHED;
                    SpawnExplosion(lander.pos);
                    PlaySound_Crash();
                    lives--;
                }
            }
            break;

        case GameState::LANDING_SUCCESS:
        case GameState::CRASHED:
            UpdateParticles();

            // Auto-advance after delay
            static int stateTimer = 0;
            stateTimer++;
            if (stateTimer > 120) {  // 2 seconds at 60 FPS
                stateTimer = 0;

                if (gameState == GameState::LANDING_SUCCESS) {
                    level++;
                    InitLander();
                    InitTerrain();
                    gameState = GameState::PLAYING;
                } else {
                    if (lives > 0) {
                        InitLander();
                        gameState = GameState::PLAYING;
                    } else {
                        if (IsHighScore(score)) {
                            gameState = GameState::ENTER_NAME;
                            nameLength = 0;
                            playerName[0] = L'\0';
                        } else {
                            gameState = GameState::GAME_OVER;
                        }
                    }
                }
            }
            break;

        default:
            break;
    }
}

/**
 * @brief Apply thrust based on input
 */
void ApplyThrust() {
    lander.mainThrusterOn = false;
    lander.leftThrusterOn = false;
    lander.rightThrusterOn = false;

    if (lander.fuel <= 0.0f) return;

    // Main thruster (up arrow or W)
    if (keys[VK_UP] || keys['W']) {
        if (lander.fuel >= FUEL_USAGE_MAIN) {
            lander.mainThrusterOn = true;
            lander.vel.y -= THRUST_POWER * std::cos(lander.rotation);
            lander.vel.x += THRUST_POWER * std::sin(lander.rotation);
            lander.fuel -= FUEL_USAGE_MAIN;
            // Play rocket sound more frequently for realistic engine roar
            if (rand() % 3 == 0) PlaySound_Thrust();
        }
    }

    // Left thruster (left arrow or A)
    if (keys[VK_LEFT] || keys['A']) {
        if (lander.fuel >= FUEL_USAGE_SIDE) {
            lander.leftThrusterOn = true;
            lander.rotation -= 0.05f;
            lander.fuel -= FUEL_USAGE_SIDE;
        }
    }

    // Right thruster (right arrow or D)
    if (keys[VK_RIGHT] || keys['D']) {
        if (lander.fuel >= FUEL_USAGE_SIDE) {
            lander.rightThrusterOn = true;
            lander.rotation += 0.05f;
            lander.fuel -= FUEL_USAGE_SIDE;
        }
    }

    // Clamp rotation
    lander.rotation = Clamp(lander.rotation, -1.57f, 1.57f);  // Â±90 degrees
}

/**
 * @brief Update physics simulation
 */
void UpdatePhysics() {
    // Apply gravity
    lander.vel.y += GRAVITY;

    // Clamp velocity
    if (lander.vel.length() > MAX_VELOCITY) {
        float ratio = MAX_VELOCITY / lander.vel.length();
        lander.vel.x *= ratio;
        lander.vel.y *= ratio;
    }

    // Update position
    lander.pos += lander.vel;

    // Wrap horizontally
    if (lander.pos.x < 0) lander.pos.x = WINDOW_WIDTH;
    if (lander.pos.x > WINDOW_WIDTH) lander.pos.x = 0;
}

/**
 * @brief Check collision with terrain
 */
bool CheckTerrainCollision() {
    // Get lander bottom point
    float landerBottom = lander.pos.y + LANDER_HEIGHT / 2.0f;
    int landerX = static_cast<int>(lander.pos.x);

    // Find terrain segment
    int segmentWidth = WINDOW_WIDTH / TERRAIN_POINTS;
    int segment = landerX / segmentWidth;
    if (segment < 0 || segment >= static_cast<int>(terrain.size()) - 1) {
        return false;
    }

    // Interpolate terrain height at lander position
    float t = static_cast<float>(landerX % segmentWidth) / segmentWidth;
    float terrainHeight = Lerp(
        static_cast<float>(terrain[segment].y),
        static_cast<float>(terrain[segment + 1].y),
        t
    );

    return landerBottom >= terrainHeight;
}

/**
 * @brief Check if collision is on landing pad
 */
bool CheckLandingPadCollision() {
    int landerX = static_cast<int>(lander.pos.x);
    int segmentWidth = WINDOW_WIDTH / TERRAIN_POINTS;
    int segment = landerX / segmentWidth;

    return segment >= landingPadStart && segment < landingPadEnd;
}

// ============================================================================
// Particle System
// ============================================================================

/**
 * @brief Spawn explosion particles
 */
void SpawnExplosion(const Vector2& pos) {
    std::uniform_real_distribution<> velDist(-3.0f, 3.0f);
    std::uniform_int_distribution<> lifeDist(30, 60);

    for (int i = 0; i < 50; i++) {
        Particle p;
        p.pos = pos;
        p.vel = Vector2(
            static_cast<float>(velDist(gen)),
            static_cast<float>(velDist(gen))
        );
        p.maxLifetime = lifeDist(gen);
        p.lifetime = p.maxLifetime;
        particles.push_back(p);
    }
}

/**
 * @brief Update all particles
 */
void UpdateParticles() {
    for (auto it = particles.begin(); it != particles.end();) {
        it->pos += it->vel;
        it->vel.y += GRAVITY / 2.0f;  // Half gravity for particles
        it->lifetime--;

        if (it->lifetime <= 0) {
            it = particles.erase(it);
        } else {
            ++it;
        }
    }
}

// ============================================================================
// Rendering Functions
// ============================================================================

/**
 * @brief Render game scene
 */
void RenderGame(HDC hdc) {
    // Create double buffer
    static HDC hdcMem = nullptr;
    static HBITMAP hbmMem = nullptr;

    if (!hdcMem) {
        hdcMem = CreateCompatibleDC(hdc);
        hbmMem = CreateCompatibleBitmap(hdc, WINDOW_WIDTH, WINDOW_HEIGHT);
        SelectObject(hdcMem, hbmMem);
    }

    // Clear background (space)
    RECT rect = {0, 0, WINDOW_WIDTH, WINDOW_HEIGHT};
    HBRUSH hBrushBlack = CreateSolidBrush(RGB(0, 0, 20));
    FillRect(hdcMem, &rect, hBrushBlack);
    DeleteObject(hBrushBlack);

    // Draw stars
    for (const auto& star : stars) {
        SetPixel(hdcMem, star.x, star.y, RGB(star.brightness, star.brightness, star.brightness));
    }

    switch (gameState) {
        case GameState::TITLE_SCREEN: {
            // Title
            SetTextColor(hdcMem, RGB(255, 255, 255));
            SetBkMode(hdcMem, TRANSPARENT);

            HFONT hFont = CreateFont(48, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
                                     DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                     CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            HFONT hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            RECT titleRect = {0, 100, WINDOW_WIDTH, 150};
            DrawText(hdcMem, L"LUNAR LANDER", -1, &titleRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);

            // Version and copyright info
            hFont = CreateFont(16, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                              DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                              CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            SetTextColor(hdcMem, RGB(180, 180, 180));
            RECT versionRect = {0, 160, WINDOW_WIDTH, 180};
            DrawText(hdcMem, L"v" LANDER_VERSION_STRING, -1, &versionRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            RECT copyrightRect = {0, 180, WINDOW_WIDTH, 200};
            DrawText(hdcMem, L"Copyright (c) 2025 Todd Dube", -1, &copyrightRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            RECT githubRect = {0, 200, WINDOW_WIDTH, 220};
            DrawText(hdcMem, L"github.com/todddube/lander", -1, &githubRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);

            // Instructions
            SetTextColor(hdcMem, RGB(255, 255, 255));
            hFont = CreateFont(20, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                              DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                              CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            const wchar_t* instructions[] = {
                L"ARROW KEYS or WASD to control thrusters",
                L"Land gently on the flat landing pad",
                L"Watch your fuel and velocity!",
                L"",
                L"Press SPACE to start",
                L"Press H for high scores"
            };

            int y = 280;
            for (const auto* text : instructions) {
                RECT textRect = {0, y, WINDOW_WIDTH, y + 25};
                DrawText(hdcMem, text, -1, &textRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
                y += 30;
            }

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);
            break;
        }

        case GameState::PLAYING:
        case GameState::LANDING_SUCCESS:
        case GameState::CRASHED: {
            // Draw terrain with retro jagged mountain look
            HPEN hPenTerrain = CreatePen(PS_SOLID, 2, RGB(180, 180, 180));
            HPEN hOldPen = (HPEN)SelectObject(hdcMem, hPenTerrain);
            HBRUSH hBrushTerrain = CreateSolidBrush(RGB(80, 80, 80));
            HBRUSH hOldBrush = (HBRUSH)SelectObject(hdcMem, hBrushTerrain);

            // Build polygon for filled terrain
            std::vector<POINT> terrainPolygon;
            for (size_t i = 0; i < terrain.size(); i++) {
                POINT pt;
                pt.x = terrain[i].x;
                pt.y = terrain[i].y;
                terrainPolygon.push_back(pt);
            }
            // Add bottom corners to close polygon
            POINT bottomRight = {WINDOW_WIDTH, WINDOW_HEIGHT};
            POINT bottomLeft = {0, WINDOW_HEIGHT};
            terrainPolygon.push_back(bottomRight);
            terrainPolygon.push_back(bottomLeft);

            // Fill terrain
            Polygon(hdcMem, terrainPolygon.data(), static_cast<int>(terrainPolygon.size()));

            // Draw landing pad with special highlight
            for (size_t i = 0; i < terrain.size() - 1; i++) {
                if (terrain[i].isLandingPad) {
                    // Draw thick green landing pad
                    HPEN hPenPad = CreatePen(PS_SOLID, 4, RGB(0, 255, 0));
                    SelectObject(hdcMem, hPenPad);
                    MoveToEx(hdcMem, terrain[i].x, terrain[i].y, nullptr);
                    LineTo(hdcMem, terrain[i + 1].x, terrain[i + 1].y);

                    // Draw landing pad markers (vertical lines)
                    if (i == static_cast<size_t>(landingPadStart)) {
                        MoveToEx(hdcMem, terrain[i].x, terrain[i].y, nullptr);
                        LineTo(hdcMem, terrain[i].x, terrain[i].y - 10);
                    }
                    if (i == static_cast<size_t>(landingPadEnd - 1)) {
                        MoveToEx(hdcMem, terrain[i + 1].x, terrain[i + 1].y, nullptr);
                        LineTo(hdcMem, terrain[i + 1].x, terrain[i + 1].y - 10);
                    }

                    DeleteObject(hPenPad);
                    SelectObject(hdcMem, hPenTerrain);
                }
            }

            SelectObject(hdcMem, hOldBrush);
            DeleteObject(hBrushTerrain);
            SelectObject(hdcMem, hOldPen);
            DeleteObject(hPenTerrain);

            // Draw particles
            for (const auto& p : particles) {
                float alpha = static_cast<float>(p.lifetime) / p.maxLifetime;
                int color = static_cast<int>(255 * alpha);
                SetPixel(hdcMem, static_cast<int>(p.pos.x), static_cast<int>(p.pos.y),
                        RGB(color, color / 2, 0));
            }

            // Draw Apollo-style lunar lander (if not crashed)
            if (!lander.crashed) {
                HPEN hPenLander = CreatePen(PS_SOLID, 2, RGB(220, 220, 220));
                hOldPen = (HPEN)SelectObject(hdcMem, hPenLander);

                float cos_r = std::cos(lander.rotation);
                float sin_r = std::sin(lander.rotation);

                // Helper lambda to rotate and translate points
                auto transformPoint = [&](float x, float y) -> POINT {
                    POINT pt;
                    pt.x = static_cast<LONG>(lander.pos.x + (x * cos_r - y * sin_r));
                    pt.y = static_cast<LONG>(lander.pos.y + (x * sin_r + y * cos_r));
                    return pt;
                };

                // Draw descent stage (square body)
                POINT body[5];
                body[0] = transformPoint(-8, -4);
                body[1] = transformPoint(8, -4);
                body[2] = transformPoint(8, 4);
                body[3] = transformPoint(-8, 4);
                body[4] = body[0];
                Polyline(hdcMem, body, 5);

                // Draw ascent stage (smaller top module)
                POINT ascent[5];
                ascent[0] = transformPoint(-5, -8);
                ascent[1] = transformPoint(5, -8);
                ascent[2] = transformPoint(5, -4);
                ascent[3] = transformPoint(-5, -4);
                ascent[4] = ascent[0];
                Polyline(hdcMem, ascent, 5);

                // Draw landing legs (four legs)
                HPEN hPenLegs = CreatePen(PS_SOLID, 1, RGB(180, 180, 180));
                SelectObject(hdcMem, hPenLegs);

                // Left legs
                POINT leftLeg1Start = transformPoint(-8, 4);
                POINT leftLeg1End = transformPoint(-12, 10);
                MoveToEx(hdcMem, leftLeg1Start.x, leftLeg1Start.y, nullptr);
                LineTo(hdcMem, leftLeg1End.x, leftLeg1End.y);

                POINT leftLeg2Start = transformPoint(-4, 4);
                POINT leftLeg2End = transformPoint(-10, 10);
                MoveToEx(hdcMem, leftLeg2Start.x, leftLeg2Start.y, nullptr);
                LineTo(hdcMem, leftLeg2End.x, leftLeg2End.y);

                // Right legs
                POINT rightLeg1Start = transformPoint(4, 4);
                POINT rightLeg1End = transformPoint(10, 10);
                MoveToEx(hdcMem, rightLeg1Start.x, rightLeg1Start.y, nullptr);
                LineTo(hdcMem, rightLeg1End.x, rightLeg1End.y);

                POINT rightLeg2Start = transformPoint(8, 4);
                POINT rightLeg2End = transformPoint(12, 10);
                MoveToEx(hdcMem, rightLeg2Start.x, rightLeg2Start.y, nullptr);
                LineTo(hdcMem, rightLeg2End.x, rightLeg2End.y);

                // Draw foot pads
                MoveToEx(hdcMem, leftLeg1End.x - 2, leftLeg1End.y, nullptr);
                LineTo(hdcMem, leftLeg1End.x + 2, leftLeg1End.y);
                MoveToEx(hdcMem, rightLeg2End.x - 2, rightLeg2End.y, nullptr);
                LineTo(hdcMem, rightLeg2End.x + 2, rightLeg2End.y);

                DeleteObject(hPenLegs);
                SelectObject(hdcMem, hPenLander);

                // Draw main thruster flame
                if (lander.mainThrusterOn) {
                    HPEN hPenFlame = CreatePen(PS_SOLID, 3, RGB(255, 200, 0));
                    SelectObject(hdcMem, hPenFlame);

                    int flameLength = 12 + (rand() % 4);  // Flickering flame
                    POINT flameStart = transformPoint(0, 4);
                    POINT flameEnd = transformPoint(0, 4 + flameLength);

                    MoveToEx(hdcMem, flameStart.x, flameStart.y, nullptr);
                    LineTo(hdcMem, flameEnd.x, flameEnd.y);

                    // Draw flame spread
                    POINT flameLeft = transformPoint(-2, 4 + flameLength - 3);
                    POINT flameRight = transformPoint(2, 4 + flameLength - 3);
                    MoveToEx(hdcMem, flameStart.x, flameStart.y, nullptr);
                    LineTo(hdcMem, flameLeft.x, flameLeft.y);
                    MoveToEx(hdcMem, flameStart.x, flameStart.y, nullptr);
                    LineTo(hdcMem, flameRight.x, flameRight.y);

                    DeleteObject(hPenFlame);
                    SelectObject(hdcMem, hPenLander);
                }

                // Draw attitude control thrusters
                if (lander.leftThrusterOn) {
                    HPEN hPenRCS = CreatePen(PS_SOLID, 2, RGB(255, 255, 100));
                    SelectObject(hdcMem, hPenRCS);
                    POINT rcsStart = transformPoint(8, -6);
                    POINT rcsEnd = transformPoint(11, -6);
                    MoveToEx(hdcMem, rcsStart.x, rcsStart.y, nullptr);
                    LineTo(hdcMem, rcsEnd.x, rcsEnd.y);
                    DeleteObject(hPenRCS);
                    SelectObject(hdcMem, hPenLander);
                }
                if (lander.rightThrusterOn) {
                    HPEN hPenRCS = CreatePen(PS_SOLID, 2, RGB(255, 255, 100));
                    SelectObject(hdcMem, hPenRCS);
                    POINT rcsStart = transformPoint(-8, -6);
                    POINT rcsEnd = transformPoint(-11, -6);
                    MoveToEx(hdcMem, rcsStart.x, rcsStart.y, nullptr);
                    LineTo(hdcMem, rcsEnd.x, rcsEnd.y);
                    DeleteObject(hPenRCS);
                    SelectObject(hdcMem, hPenLander);
                }

                SelectObject(hdcMem, hOldPen);
                DeleteObject(hPenLander);
            }

            // Draw HUD
            SetTextColor(hdcMem, RGB(255, 255, 255));
            SetBkMode(hdcMem, TRANSPARENT);

            HFONT hFont = CreateFont(16, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                                     DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                     CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Courier New");
            HFONT hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            wchar_t buffer[256];
            StringCchPrintf(buffer, 256, L"Score: %d", score);
            TextOut(hdcMem, 10, 10, buffer, wcslen(buffer));

            StringCchPrintf(buffer, 256, L"Level: %d", level);
            TextOut(hdcMem, 10, 30, buffer, wcslen(buffer));

            StringCchPrintf(buffer, 256, L"Lives: %d", lives);
            TextOut(hdcMem, 10, 50, buffer, wcslen(buffer));

            StringCchPrintf(buffer, 256, L"Fuel: %.1f", lander.fuel);
            TextOut(hdcMem, 10, 70, buffer, wcslen(buffer));

            StringCchPrintf(buffer, 256, L"Velocity: %.2f", lander.vel.length());
            TextOut(hdcMem, 10, 90, buffer, wcslen(buffer));

            // Velocity indicator
            if (lander.vel.length() > SAFE_LANDING_SPEED) {
                SetTextColor(hdcMem, RGB(255, 0, 0));
                TextOut(hdcMem, 150, 90, L"TOO FAST!", 9);
                SetTextColor(hdcMem, RGB(255, 255, 255));
            }

            // State messages
            if (gameState == GameState::LANDING_SUCCESS) {
                HFONT hBigFont = CreateFont(36, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
                                           DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                           CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
                SelectObject(hdcMem, hBigFont);
                SetTextColor(hdcMem, RGB(0, 255, 0));

                RECT msgRect = {0, WINDOW_HEIGHT / 2 - 50, WINDOW_WIDTH, WINDOW_HEIGHT / 2 + 50};
                DrawText(hdcMem, L"LANDING SUCCESSFUL!", -1, &msgRect,
                        DT_CENTER | DT_VCENTER | DT_SINGLELINE);

                SelectObject(hdcMem, hFont);
                DeleteObject(hBigFont);
                SetTextColor(hdcMem, RGB(255, 255, 255));
            } else if (gameState == GameState::CRASHED) {
                HFONT hBigFont = CreateFont(36, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
                                           DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                           CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
                SelectObject(hdcMem, hBigFont);
                SetTextColor(hdcMem, RGB(255, 0, 0));

                RECT msgRect = {0, WINDOW_HEIGHT / 2 - 50, WINDOW_WIDTH, WINDOW_HEIGHT / 2 + 50};
                DrawText(hdcMem, L"CRASHED!", -1, &msgRect,
                        DT_CENTER | DT_VCENTER | DT_SINGLELINE);

                SelectObject(hdcMem, hFont);
                DeleteObject(hBigFont);
                SetTextColor(hdcMem, RGB(255, 255, 255));
            }

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);
            break;
        }

        case GameState::GAME_OVER: {
            SetTextColor(hdcMem, RGB(255, 255, 255));
            SetBkMode(hdcMem, TRANSPARENT);

            HFONT hFont = CreateFont(48, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
                                     DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                     CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            HFONT hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            RECT titleRect = {0, 150, WINDOW_WIDTH, 200};
            DrawText(hdcMem, L"GAME OVER", -1, &titleRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);

            hFont = CreateFont(24, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                              DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                              CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            wchar_t buffer[128];
            StringCchPrintf(buffer, 128, L"Final Score: %d", score);
            RECT scoreRect = {0, 250, WINDOW_WIDTH, 280};
            DrawText(hdcMem, buffer, -1, &scoreRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            StringCchPrintf(buffer, 128, L"Level Reached: %d", level);
            RECT levelRect = {0, 290, WINDOW_WIDTH, 320};
            DrawText(hdcMem, buffer, -1, &levelRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            RECT instructRect = {0, 380, WINDOW_WIDTH, 410};
            DrawText(hdcMem, L"Press SPACE to play again", -1, &instructRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);
            break;
        }

        case GameState::ENTER_NAME: {
            SetTextColor(hdcMem, RGB(255, 255, 255));
            SetBkMode(hdcMem, TRANSPARENT);

            HFONT hFont = CreateFont(36, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
                                     DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                     CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            HFONT hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            RECT titleRect = {0, 150, WINDOW_WIDTH, 200};
            DrawText(hdcMem, L"HIGH SCORE!", -1, &titleRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);

            hFont = CreateFont(20, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                              DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                              CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            RECT promptRect = {0, 250, WINDOW_WIDTH, 280};
            DrawText(hdcMem, L"Enter your name:", -1, &promptRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            // Draw name input box with dark background
            RECT nameRect = {WINDOW_WIDTH / 2 - 100, 300, WINDOW_WIDTH / 2 + 100, 340};

            // Fill background with dark color
            HBRUSH hBrushInput = CreateSolidBrush(RGB(20, 20, 40));
            FillRect(hdcMem, &nameRect, hBrushInput);
            DeleteObject(hBrushInput);

            // Draw border
            HPEN hPenBorder = CreatePen(PS_SOLID, 2, RGB(0, 255, 0));
            HPEN hOldPen = (HPEN)SelectObject(hdcMem, hPenBorder);
            SelectObject(hdcMem, GetStockObject(NULL_BRUSH));
            Rectangle(hdcMem, nameRect.left, nameRect.top, nameRect.right, nameRect.bottom);
            SelectObject(hdcMem, hOldPen);
            DeleteObject(hPenBorder);

            // Draw text in bright green
            SetTextColor(hdcMem, RGB(0, 255, 0));
            DrawText(hdcMem, playerName, -1, &nameRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            // Draw cursor blink
            static int cursorBlink = 0;
            cursorBlink = (cursorBlink + 1) % 60;
            if (cursorBlink < 30 && nameLength < 20) {
                SIZE textSize;
                HDC hdcTemp = GetDC(nullptr);
                SelectObject(hdcTemp, hFont);
                GetTextExtentPoint32(hdcTemp, playerName, nameLength, &textSize);
                ReleaseDC(nullptr, hdcTemp);

                int cursorX = (WINDOW_WIDTH / 2) + (textSize.cx / 2) + 2;
                MoveToEx(hdcMem, cursorX, nameRect.top + 10, nullptr);
                LineTo(hdcMem, cursorX, nameRect.bottom - 10);
            }

            SetTextColor(hdcMem, RGB(255, 255, 255));
            RECT instructRect = {0, 380, WINDOW_WIDTH, 410};
            DrawText(hdcMem, L"Press ENTER when done", -1, &instructRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);
            break;
        }

        case GameState::HIGH_SCORES: {
            SetTextColor(hdcMem, RGB(255, 255, 255));
            SetBkMode(hdcMem, TRANSPARENT);

            HFONT hFont = CreateFont(36, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
                                     DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                     CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            HFONT hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            RECT titleRect = {0, 50, WINDOW_WIDTH, 100};
            DrawText(hdcMem, L"HIGH SCORES", -1, &titleRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);

            hFont = CreateFont(20, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                              DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                              CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Courier New");
            hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            int y = 130;
            wchar_t buffer[256];
            for (int i = 0; i < MAX_HIGH_SCORES; i++) {
                if (highScores[i].score > 0) {
                    StringCchPrintf(buffer, 256, L"%2d. %-20s %6d  Lvl %2d",
                                   i + 1, highScores[i].name, highScores[i].score, highScores[i].level);
                    TextOut(hdcMem, 100, y, buffer, wcslen(buffer));
                } else {
                    StringCchPrintf(buffer, 256, L"%2d. ---", i + 1);
                    TextOut(hdcMem, 100, y, buffer, wcslen(buffer));
                }
                y += 35;
            }

            RECT instructRect = {0, 520, WINDOW_WIDTH, 550};
            DrawText(hdcMem, L"Press ESC to return", -1, &instructRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);
            break;
        }

        default:
            break;
    }

    // Copy back buffer to screen
    BitBlt(hdc, 0, 0, WINDOW_WIDTH, WINDOW_HEIGHT, hdcMem, 0, 0, SRCCOPY);
}

// ============================================================================
// High Score Functions
// ============================================================================

/**
 * @brief Check if score qualifies for high score list
 */
bool IsHighScore(int newScore) {
    if (highScores.empty()) return true;
    return newScore > highScores[MAX_HIGH_SCORES - 1].score;
}

/**
 * @brief Update high score list with new score
 */
void UpdateHighScores(int newScore, int newLevel) {
    HighScore newEntry;
    newEntry.score = newScore;
    newEntry.level = newLevel;
    StringCchCopy(newEntry.name, 32, playerName);

    // Insert into sorted position
    bool inserted = false;
    for (int i = 0; i < MAX_HIGH_SCORES; i++) {
        if (newScore > highScores[i].score) {
            // Shift down
            for (int j = MAX_HIGH_SCORES - 1; j > i; j--) {
                highScores[j] = highScores[j - 1];
            }
            highScores[i] = newEntry;
            inserted = true;
            break;
        }
    }

    if (!inserted && highScores.size() < static_cast<size_t>(MAX_HIGH_SCORES)) {
        highScores.push_back(newEntry);
    }

    SaveHighScores();
}

/**
 * @brief Save high scores to file
 */
void SaveHighScores() {
    std::ofstream file(HIGH_SCORE_FILE, std::ios::binary);
    if (file.is_open()) {
        for (const auto& score : highScores) {
            file.write(reinterpret_cast<const char*>(&score), sizeof(HighScore));
        }
        file.close();
    }
}

/**
 * @brief Load high scores from file
 */
void LoadHighScores() {
    std::ifstream file(HIGH_SCORE_FILE, std::ios::binary);
    if (file.is_open()) {
        highScores.clear();
        HighScore score;
        while (file.read(reinterpret_cast<char*>(&score), sizeof(HighScore))) {
            highScores.push_back(score);
        }
        file.close();
    }

    // Fill remaining slots with empty scores
    while (highScores.size() < static_cast<size_t>(MAX_HIGH_SCORES)) {
        HighScore emptyScore;
        highScores.push_back(emptyScore);
    }
}

// ============================================================================
// Sound Functions
// ============================================================================

/**
 * @brief Play thrust sound effect - realistic rocket roar
 */
void PlaySound_Thrust() {
    // Simulate rocket engine roar with multiple low frequencies
    // Alternating between frequencies creates a rumbling effect
    int baseFreq = 80 + (rand() % 40);  // Random variation 80-120 Hz
    Beep(baseFreq, 15);
    Beep(baseFreq + 30, 15);
}

/**
 * @brief Play crash sound effect
 */
void PlaySound_Crash() {
    Beep(100, 300);
}

/**
 * @brief Play landing sound effect
 */
void PlaySound_Landing() {
    Beep(800, 100);
    Beep(600, 100);
    Beep(400, 200);
}

/**
 * @brief Play menu selection sound
 */
void PlaySound_MenuSelect() {
    Beep(440, 100);
}

// ============================================================================
// Utility Functions
// ============================================================================

/**
 * @brief Linear interpolation
 */
float Lerp(float a, float b, float t) {
    return a + (b - a) * t;
}

/**
 * @brief Clamp value between min and max
 */
float Clamp(float value, float min, float max) {
    if (value < min) return min;
    if (value > max) return max;
    return value;
}

// ============================================================================
// Windows Message Handling
// ============================================================================

/**
 * @brief Window procedure callback
 */
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    switch (uMsg) {
        case WM_CREATE:
            LoadHighScores();
            InitStars();
            SetTimer(hwnd, 1, TARGET_FRAME_TIME, nullptr);
            return 0;

        case WM_DESTROY:
            SaveHighScores();
            PostQuitMessage(0);
            return 0;

        case WM_TIMER:
            if (gameState == GameState::PLAYING ||
                gameState == GameState::LANDING_SUCCESS ||
                gameState == GameState::CRASHED) {
                UpdateGame();
            }
            InvalidateRect(hwnd, nullptr, FALSE);
            return 0;

        case WM_PAINT: {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hwnd, &ps);
            RenderGame(hdc);
            EndPaint(hwnd, &ps);
            return 0;
        }

        case WM_KEYDOWN:
            keys[wParam] = true;

            // Handle game state transitions
            switch (gameState) {
                case GameState::TITLE_SCREEN:
                    if (wParam == VK_SPACE) {
                        InitGame();
                        PlaySound_MenuSelect();
                    } else if (wParam == 'H') {
                        gameState = GameState::HIGH_SCORES;
                        PlaySound_MenuSelect();
                    }
                    break;

                case GameState::GAME_OVER:
                    if (wParam == VK_SPACE) {
                        InitGame();
                        PlaySound_MenuSelect();
                    }
                    break;

                case GameState::HIGH_SCORES:
                    if (wParam == VK_ESCAPE) {
                        gameState = GameState::TITLE_SCREEN;
                        PlaySound_MenuSelect();
                    }
                    break;

                case GameState::ENTER_NAME:
                    if (wParam == VK_RETURN && nameLength > 0) {
                        UpdateHighScores(score, level);
                        gameState = GameState::HIGH_SCORES;
                        PlaySound_MenuSelect();
                    } else if (wParam == VK_BACK && nameLength > 0) {
                        nameLength--;
                        playerName[nameLength] = L'\0';
                    }
                    break;

                case GameState::PLAYING:
                    if (wParam == VK_ESCAPE) {
                        gameState = GameState::TITLE_SCREEN;
                    } else if (wParam == 'P') {
                        gameState = GameState::PAUSED;
                    }
                    break;

                case GameState::PAUSED:
                    if (wParam == 'P' || wParam == VK_ESCAPE) {
                        gameState = GameState::PLAYING;
                    }
                    break;

                default:
                    break;
            }
            return 0;

        case WM_KEYUP:
            keys[wParam] = false;
            return 0;

        case WM_CHAR:
            if (gameState == GameState::ENTER_NAME) {
                if (wParam >= 32 && wParam < 127 && nameLength < 20) {
                    playerName[nameLength++] = static_cast<wchar_t>(wParam);
                    playerName[nameLength] = L'\0';
                }
            }
            return 0;

        default:
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
}

// ============================================================================
// Main Entry Point
// ============================================================================

/**
 * @brief Application entry point
 */
int WINAPI WinMain(
    _In_ HINSTANCE hInstance,
    _In_opt_ HINSTANCE hPrevInstance,
    _In_ LPSTR lpCmdLine,
    _In_ int nCmdShow
) {
    (void)hPrevInstance;
    (void)lpCmdLine;

    // Register window class
    const wchar_t CLASS_NAME[] = L"LunarLanderClass";

    WNDCLASS wc = {};
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = CLASS_NAME;
    wc.hCursor = LoadCursor(nullptr, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);

    RegisterClass(&wc);

    // Create window
    DWORD dwStyle = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX;
    RECT windowRect = {0, 0, WINDOW_WIDTH, WINDOW_HEIGHT};
    AdjustWindowRect(&windowRect, dwStyle, FALSE);

    int windowWidth = windowRect.right - windowRect.left;
    int windowHeight = windowRect.bottom - windowRect.top;

    HWND hwnd = CreateWindowEx(
        0,
        CLASS_NAME,
        L"Lunar Lander",
        dwStyle,
        CW_USEDEFAULT, CW_USEDEFAULT,
        windowWidth, windowHeight,
        nullptr,
        nullptr,
        hInstance,
        nullptr
    );

    if (hwnd == nullptr) {
        return 0;
    }

    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    // Game loop
    MSG msg = {};
    while (GetMessage(&msg, nullptr, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return static_cast<int>(msg.wParam);
}
