/**
 * @file lander.cpp
 * @brief Classic lunar lander game for Windows
 * @author Todd Dube
 * @copyright Copyright (c) 2025 Todd Dube
 *
 * A classic lunar lander game with physics simulation, terrain generation,
 * and multiple difficulty levels. Navigate your lander to safe landing zones
 * while managing fuel and velocity.
 */

// ============================================================================
// Platform Configuration and Unicode Setup
// ============================================================================
#ifndef UNICODE
#define UNICODE
#endif
#ifndef _UNICODE
#define _UNICODE
#endif

// ============================================================================
// System and Library Includes
// ============================================================================
#include <windows.h>
#include <windowsx.h>
#include <strsafe.h>
#include <vector>
#include <cmath>
#include <algorithm>
#include <random>
#include <string>
#include <fstream>

// Include version header (generated by build system)
#ifdef _MSC_VER
#include "version.h"
#else
// Fallback for manual compilation
#define LANDER_VERSION_STRING "1.0.0"
#define LANDER_AUTHOR "Todd Dube"
#define LANDER_COPYRIGHT "Copyright (c) 2025 Todd Dube"
#endif

// ============================================================================
// Game Constants
// ============================================================================
constexpr int WINDOW_WIDTH = 800;
constexpr int WINDOW_HEIGHT = 600;
constexpr float GRAVITY = 0.05f;           // Downward acceleration per frame
constexpr float THRUST_POWER = 0.12f;      // Upward acceleration from main thruster
constexpr float SIDE_THRUST_POWER = 0.08f; // Horizontal acceleration from side thrusters
constexpr float MAX_VELOCITY = 15.0f;      // Terminal velocity
constexpr float SAFE_LANDING_SPEED = 1.5f; // Maximum safe landing velocity
constexpr float FUEL_USAGE_MAIN = 0.3f;    // Fuel consumed per frame for main thruster
constexpr float FUEL_USAGE_SIDE = 0.15f;    // Fuel consumed per frame for side thrusters
constexpr float INITIAL_FUEL = 100.0f;     // Starting fuel amount
constexpr int TERRAIN_POINTS = 100;        // Number of terrain vertices
constexpr int MIN_LANDING_PAD_WIDTH = 40;  // Minimum width of landing pad
constexpr int MAX_LANDING_PAD_WIDTH = 80;  // Maximum width of landing pad
constexpr int LANDER_WIDTH = 20;           // Width of lander
constexpr int LANDER_HEIGHT = 20;          // Height of lander
constexpr int MAX_HIGH_SCORES = 10;        // Number of high scores to track
constexpr int STAR_COUNT = 100;            // Number of background stars

// Scoring constants
constexpr int SCORE_BASE_LANDING = 100;    // Base score for successful landing
constexpr int SCORE_FUEL_BONUS = 2;        // Points per unit of remaining fuel
constexpr int SCORE_SPEED_BONUS = 50;      // Bonus for gentle landing
constexpr int SCORE_CENTER_BONUS = 100;    // Bonus for landing in center of pad

// ============================================================================
// Core Data Structures
// ============================================================================

/**
 * @brief 2D vector for position and velocity
 */
struct Vector2 {
    float x{0.0f};
    float y{0.0f};

    constexpr Vector2() = default;
    constexpr Vector2(float _x, float _y) : x(_x), y(_y) {}

    constexpr Vector2 operator+(const Vector2& v) const noexcept {
        return Vector2(x + v.x, y + v.y);
    }

    constexpr Vector2 operator-(const Vector2& v) const noexcept {
        return Vector2(x - v.x, y - v.y);
    }

    constexpr Vector2 operator*(float scalar) const noexcept {
        return Vector2(x * scalar, y * scalar);
    }

    Vector2& operator+=(const Vector2& v) noexcept {
        x += v.x;
        y += v.y;
        return *this;
    }

    float length() const noexcept {
        return std::sqrt(x * x + y * y);
    }
};

/**
 * @brief Lunar lander spacecraft
 */
struct Lander {
    Vector2 pos{WINDOW_WIDTH / 2.0f, 50.0f}; // Current position
    Vector2 vel{0.0f, 0.0f};                 // Current velocity
    float fuel{INITIAL_FUEL};                // Remaining fuel
    float rotation{0.0f};                    // Rotation angle in radians
    bool mainThrusterOn{false};              // Main thruster state
    bool leftThrusterOn{false};              // Left thruster state
    bool rightThrusterOn{false};             // Right thruster state
    bool crashed{false};                     // Crash state
    bool landed{false};                      // Landed state
};

/**
 * @brief Terrain point
 */
struct TerrainPoint {
    int x{0};
    int y{0};
    bool isLandingPad{false};  // True if this segment is a landing pad
};

/**
 * @brief Particle for explosion effects
 */
struct Particle {
    Vector2 pos;
    Vector2 vel;
    int lifetime{0};  // Frames remaining
    int maxLifetime{0};
    int type{0};  // 0=fire, 1=smoke, 2=debris, 3=lander_debris
    COLORREF color{RGB(255, 128, 0)};
    float rotation{0.0f};       // For lander debris
    float rotationSpeed{0.0f};  // For lander debris
    Vector2 endPos{0.0f, 0.0f}; // For drawing lines (lander pieces)
};

/**
 * @brief Star for background
 */
struct Star {
    int x{0};
    int y{0};
    int brightness{0};  // 0-255
};

/**
 * @brief High score entry
 */
struct HighScore {
    int score{0};
    int level{1};
    wchar_t name[32]{L"---"};
};

/**
 * @brief Game state enumeration
 */
enum class GameState {
    TITLE_SCREEN,
    PLAYING,
    PAUSED,
    LANDING_SUCCESS,
    CRASHED,
    GAME_OVER,
    HIGH_SCORES,
    ENTER_NAME
};

// ============================================================================
// Global Game State
// ============================================================================

// Game objects
Lander lander;
std::vector<TerrainPoint> terrain;
std::vector<Particle> particles;
std::vector<Star> stars;
std::vector<HighScore> highScores(MAX_HIGH_SCORES);

// Game state
GameState gameState = GameState::TITLE_SCREEN;
int score = 0;
int level = 1;
int lives = 3;
int landingPadStart = 0;  // Index of landing pad start in terrain
int landingPadEnd = 0;    // Index of landing pad end in terrain

// Input state
bool keys[256] = {false};

// UI state
wchar_t playerName[32] = L"";
int nameLength = 0;

// Random number generator
std::random_device rd;
std::mt19937 gen(rd());

// High score file path
const wchar_t* HIGH_SCORE_FILE = L"lander_scores.dat";

// Timing
DWORD lastFrameTime = 0;
constexpr DWORD TARGET_FRAME_TIME = 16;  // ~60 FPS

// Sound state for realistic audio using waveOut
bool thrustSoundActive = false;
HANDLE thrustSoundThread = nullptr;
HWAVEOUT hWaveOut = nullptr;
WAVEHDR waveHeader[2] = {};
bool soundInitialized = false;

// ============================================================================
// Function Prototypes
// ============================================================================

// Initialization
void InitGame();
void InitStars();
void InitTerrain();
void InitLander();

// Game loop
void UpdateGame();
void RenderGame(HDC hdc);

// Physics
void UpdatePhysics();
void ApplyThrust();
bool CheckTerrainCollision();
bool CheckLandingPadCollision();

// Particles
void SpawnExplosion(const Vector2& pos);
void SpawnLanderDebris(const Vector2& pos, float rotation);
void UpdateParticles();

// High scores
void UpdateHighScores(int newScore, int newLevel);
void SaveHighScores();
void LoadHighScores();
bool IsHighScore(int newScore);

// Sound generation
void PlaySound_Thrust();
void StopSound_Thrust();
void PlaySound_Crash();
void PlaySound_Landing();
void PlaySound_MenuSelect();

// Utility
float Lerp(float a, float b, float t);
float Clamp(float value, float min, float max);

// Windows message handling
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

// ============================================================================
// Initialization Functions
// ============================================================================

/**
 * @brief Initialize new game
 */
void InitGame() {
    score = 0;
    level = 1;
    lives = 3;
    gameState = GameState::PLAYING;

    InitLander();
    InitTerrain();
    InitStars();

    particles.clear();
}

/**
 * @brief Initialize background stars
 */
void InitStars() {
    stars.clear();
    std::uniform_int_distribution<> xDist(0, WINDOW_WIDTH);
    std::uniform_int_distribution<> yDist(0, WINDOW_HEIGHT / 2);
    std::uniform_int_distribution<> brightDist(50, 255);

    for (int i = 0; i < STAR_COUNT; i++) {
        Star star;
        star.x = xDist(gen);
        star.y = yDist(gen);
        star.brightness = brightDist(gen);
        stars.push_back(star);
    }
}

/**
 * @brief Generate random terrain with landing pad
 */
void InitTerrain() {
    terrain.clear();

    // Generate terrain heights
    std::uniform_int_distribution<> heightDist(
        WINDOW_HEIGHT - 200 + (level * 5),  // Terrain gets higher each level
        WINDOW_HEIGHT - 50
    );
    std::uniform_int_distribution<> roughnessDist(
        -20 - (level * 2),  // Terrain gets rougher each level
        20 + (level * 2)
    );

    int segmentWidth = WINDOW_WIDTH / TERRAIN_POINTS;
    int currentHeight = heightDist(gen);

    // Choose random location for landing pad
    std::uniform_int_distribution<> padPosDist(
        TERRAIN_POINTS / 4,
        (TERRAIN_POINTS * 3) / 4
    );
    int padPosition = padPosDist(gen);
    int padWidth = (MIN_LANDING_PAD_WIDTH + MAX_LANDING_PAD_WIDTH) / (2 * segmentWidth);

    landingPadStart = padPosition;
    landingPadEnd = padPosition + padWidth;

    // Generate terrain points
    for (int i = 0; i < TERRAIN_POINTS; i++) {
        TerrainPoint point;
        point.x = i * segmentWidth;

        // Landing pad is flat
        if (i >= landingPadStart && i < landingPadEnd) {
            point.y = currentHeight;
            point.isLandingPad = true;
        } else {
            currentHeight += roughnessDist(gen);
            currentHeight = static_cast<int>(Clamp(
                static_cast<float>(currentHeight),
                static_cast<float>(WINDOW_HEIGHT - 200),
                static_cast<float>(WINDOW_HEIGHT - 50)
            ));
            point.y = currentHeight;
            point.isLandingPad = false;
        }

        terrain.push_back(point);
    }

    // Ensure last point connects to edge
    terrain.back().x = WINDOW_WIDTH;
}

/**
 * @brief Initialize lander at start position
 */
void InitLander() {
    lander.pos = Vector2(WINDOW_WIDTH / 2.0f, 50.0f);
    lander.vel = Vector2(0.0f, 0.0f);
    lander.fuel = INITIAL_FUEL + (level * 10.0f);  // Bonus fuel each level
    lander.rotation = 0.0f;
    lander.mainThrusterOn = false;
    lander.leftThrusterOn = false;
    lander.rightThrusterOn = false;
    lander.crashed = false;
    lander.landed = false;
}

// ============================================================================
// Game Loop Functions
// ============================================================================

/**
 * @brief Update game state
 */
void UpdateGame() {
    switch (gameState) {
        case GameState::PLAYING:
            ApplyThrust();
            UpdatePhysics();
            UpdateParticles();

            // Check for crash or landing
            if (CheckTerrainCollision()) {
                if (CheckLandingPadCollision() &&
                    lander.vel.length() < SAFE_LANDING_SPEED &&
                    std::abs(lander.rotation) < 0.2f) {
                    // Successful landing
                    lander.landed = true;
                    lander.vel = Vector2(0.0f, 0.0f);
                    gameState = GameState::LANDING_SUCCESS;
                    StopSound_Thrust();  // Stop thrust sound on landing
                    PlaySound_Landing();

                    // Calculate score
                    int landingScore = SCORE_BASE_LANDING;
                    landingScore += static_cast<int>(lander.fuel) * SCORE_FUEL_BONUS;
                    if (lander.vel.length() < SAFE_LANDING_SPEED / 2.0f) {
                        landingScore += SCORE_SPEED_BONUS;
                    }
                    // Check if landed in center of pad
                    float padCenterX = (terrain[landingPadStart].x + terrain[landingPadEnd].x) / 2.0f;
                    if (std::abs(lander.pos.x - padCenterX) < 20.0f) {
                        landingScore += SCORE_CENTER_BONUS;
                    }
                    score += landingScore * level;  // Multiply by level
                } else {
                    // Crash
                    lander.crashed = true;
                    lander.vel = Vector2(0.0f, 0.0f);
                    gameState = GameState::CRASHED;
                    StopSound_Thrust();  // Stop thrust sound on crash
                    SpawnExplosion(lander.pos);
                    SpawnLanderDebris(lander.pos, lander.rotation);  // Break apart lander
                    PlaySound_Crash();
                    lives--;
                }
            }
            break;

        case GameState::LANDING_SUCCESS:
        case GameState::CRASHED:
            UpdateParticles();

            // Auto-advance after delay
            static int stateTimer = 0;
            stateTimer++;
            if (stateTimer > 120) {  // 2 seconds at 60 FPS
                stateTimer = 0;

                if (gameState == GameState::LANDING_SUCCESS) {
                    level++;
                    InitLander();
                    InitTerrain();
                    gameState = GameState::PLAYING;
                } else {
                    if (lives > 0) {
                        InitLander();
                        gameState = GameState::PLAYING;
                    } else {
                        if (IsHighScore(score)) {
                            gameState = GameState::ENTER_NAME;
                            nameLength = 0;
                            playerName[0] = L'\0';
                        } else {
                            gameState = GameState::GAME_OVER;
                        }
                    }
                }
            }
            break;

        default:
            break;
    }
}

/**
 * @brief Apply thrust based on input
 */
void ApplyThrust() {
    lander.mainThrusterOn = false;
    lander.leftThrusterOn = false;
    lander.rightThrusterOn = false;

    if (lander.fuel <= 0.0f) {
        StopSound_Thrust();
        return;
    }

    // Main thruster (up arrow, W, or spacebar)
    if (keys[VK_UP] || keys['W'] || keys[VK_SPACE]) {
        if (lander.fuel >= FUEL_USAGE_MAIN) {
            lander.mainThrusterOn = true;
            lander.vel.y -= THRUST_POWER * std::cos(lander.rotation);
            lander.vel.x += THRUST_POWER * std::sin(lander.rotation);
            lander.fuel -= FUEL_USAGE_MAIN;
            PlaySound_Thrust();  // Start continuous thrust sound
        }
    } else {
        StopSound_Thrust();  // Stop sound when thruster is off
    }

    // Left thruster (left arrow or A)
    if (keys[VK_LEFT] || keys['A']) {
        if (lander.fuel >= FUEL_USAGE_SIDE) {
            lander.leftThrusterOn = true;
            lander.rotation -= 0.05f;
            lander.fuel -= FUEL_USAGE_SIDE;
        }
    }

    // Right thruster (right arrow or D)
    if (keys[VK_RIGHT] || keys['D']) {
        if (lander.fuel >= FUEL_USAGE_SIDE) {
            lander.rightThrusterOn = true;
            lander.rotation += 0.05f;
            lander.fuel -= FUEL_USAGE_SIDE;
        }
    }

    // Clamp rotation
    lander.rotation = Clamp(lander.rotation, -1.57f, 1.57f);  // Â±90 degrees
}

/**
 * @brief Update physics simulation
 */
void UpdatePhysics() {
    // Apply gravity
    lander.vel.y += GRAVITY;

    // Clamp velocity
    if (lander.vel.length() > MAX_VELOCITY) {
        float ratio = MAX_VELOCITY / lander.vel.length();
        lander.vel.x *= ratio;
        lander.vel.y *= ratio;
    }

    // Update position
    lander.pos += lander.vel;

    // Wrap horizontally
    if (lander.pos.x < 0) lander.pos.x = WINDOW_WIDTH;
    if (lander.pos.x > WINDOW_WIDTH) lander.pos.x = 0;
}

/**
 * @brief Check collision with terrain
 */
bool CheckTerrainCollision() {
    // Get lander bottom point
    float landerBottom = lander.pos.y + LANDER_HEIGHT / 2.0f;
    int landerX = static_cast<int>(lander.pos.x);

    // Find terrain segment
    int segmentWidth = WINDOW_WIDTH / TERRAIN_POINTS;
    int segment = landerX / segmentWidth;
    if (segment < 0 || segment >= static_cast<int>(terrain.size()) - 1) {
        return false;
    }

    // Interpolate terrain height at lander position
    float t = static_cast<float>(landerX % segmentWidth) / segmentWidth;
    float terrainHeight = Lerp(
        static_cast<float>(terrain[segment].y),
        static_cast<float>(terrain[segment + 1].y),
        t
    );

    return landerBottom >= terrainHeight;
}

/**
 * @brief Check if collision is on landing pad
 */
bool CheckLandingPadCollision() {
    int landerX = static_cast<int>(lander.pos.x);
    int segmentWidth = WINDOW_WIDTH / TERRAIN_POINTS;
    int segment = landerX / segmentWidth;

    return segment >= landingPadStart && segment < landingPadEnd;
}

// ============================================================================
// Particle System
// ============================================================================

/**
 * @brief Spawn explosion particles - enhanced with multiple particle types
 */
void SpawnExplosion(const Vector2& pos) {
    std::uniform_real_distribution<> velDist(-5.0f, 5.0f);
    std::uniform_real_distribution<> fastVelDist(-8.0f, 8.0f);
    std::uniform_int_distribution<> lifeDist(20, 50);
    std::uniform_int_distribution<> longLifeDist(40, 80);
    std::uniform_int_distribution<> typeDist(0, 2);

    // Create 150 particles for a more dramatic explosion
    for (int i = 0; i < 150; i++) {
        Particle p;
        p.pos = pos;
        p.type = typeDist(gen);

        // Different particle types have different properties
        switch (p.type) {
            case 0:  // Fire/explosion particles (fast, bright, short-lived)
                p.vel = Vector2(
                    static_cast<float>(fastVelDist(gen)),
                    static_cast<float>(fastVelDist(gen)) - 2.0f  // Slight upward bias
                );
                p.maxLifetime = lifeDist(gen);
                p.color = RGB(255, 100 + rand() % 156, 0);  // Orange to yellow
                break;

            case 1:  // Smoke particles (slower, gray, longer-lived)
                p.vel = Vector2(
                    static_cast<float>(velDist(gen)) * 0.5f,
                    static_cast<float>(velDist(gen)) * 0.5f - 1.0f  // Float upward
                );
                p.maxLifetime = longLifeDist(gen);
                p.color = RGB(100 + rand() % 100, 100 + rand() % 100, 100 + rand() % 100);
                break;

            case 2:  // Debris particles (medium speed, various colors)
                p.vel = Vector2(
                    static_cast<float>(velDist(gen)),
                    static_cast<float>(velDist(gen))
                );
                p.maxLifetime = lifeDist(gen) + 20;
                int brightness = 150 + rand() % 106;
                p.color = RGB(brightness, brightness, brightness);
                break;
        }

        p.lifetime = p.maxLifetime;
        particles.push_back(p);
    }
}

/**
 * @brief Spawn lander debris pieces - visual breakup on crash
 */
void SpawnLanderDebris(const Vector2& pos, float rotation) {
    std::uniform_real_distribution<> velDist(-4.0f, 4.0f);
    std::uniform_real_distribution<> spinDist(-0.2f, 0.2f);
    std::uniform_int_distribution<> lifeDist(60, 120);

    float cos_r = std::cos(rotation);
    float sin_r = std::sin(rotation);

    // Create debris pieces representing lander structure breaking apart
    // Each piece is a line segment with endpoints

    // Body fragments (4 pieces from the main body)
    for (int i = 0; i < 4; i++) {
        Particle p;
        p.type = 3;  // Lander debris
        p.pos = pos;
        p.vel = Vector2(
            static_cast<float>(velDist(gen)),
            static_cast<float>(velDist(gen)) - 2.0f  // Initial upward burst
        );
        p.rotation = rotation + (rand() % 100 - 50) * 0.01f;
        p.rotationSpeed = static_cast<float>(spinDist(gen));
        p.maxLifetime = lifeDist(gen);
        p.lifetime = p.maxLifetime;
        p.color = RGB(220, 220, 220);  // Lander color

        // Different body pieces
        switch (i) {
            case 0: p.endPos = Vector2(16.0f, 0.0f); break;   // Top piece
            case 1: p.endPos = Vector2(-16.0f, 0.0f); break;  // Bottom piece
            case 2: p.endPos = Vector2(0.0f, 12.0f); break;   // Side piece
            case 3: p.endPos = Vector2(0.0f, -12.0f); break;  // Other side
        }

        particles.push_back(p);
    }

    // Landing leg fragments (4 legs breaking off)
    for (int i = 0; i < 4; i++) {
        Particle p;
        p.type = 3;  // Lander debris
        p.pos = pos;
        p.vel = Vector2(
            static_cast<float>(velDist(gen)) * 1.5f,  // Legs fly farther
            static_cast<float>(velDist(gen))
        );
        p.rotation = rotation + (rand() % 360) * 0.0174f;  // Random rotation
        p.rotationSpeed = static_cast<float>(spinDist(gen)) * 2.0f;  // Spin faster
        p.maxLifetime = lifeDist(gen);
        p.lifetime = p.maxLifetime;
        p.color = RGB(180, 180, 180);  // Slightly darker for legs
        p.endPos = Vector2(10.0f + rand() % 5, 0.0f);  // Leg length

        particles.push_back(p);
    }
}

/**
 * @brief Update all particles
 */
void UpdateParticles() {
    for (auto it = particles.begin(); it != particles.end();) {
        it->pos += it->vel;
        it->vel.y += GRAVITY / 2.0f;  // Half gravity for particles
        it->lifetime--;

        // Update rotation for lander debris
        if (it->type == 3) {
            it->rotation += it->rotationSpeed;
        }

        if (it->lifetime <= 0) {
            it = particles.erase(it);
        } else {
            ++it;
        }
    }
}

// ============================================================================
// Rendering Functions
// ============================================================================

/**
 * @brief Render game scene
 */
void RenderGame(HDC hdc) {
    // Create double buffer
    static HDC hdcMem = nullptr;
    static HBITMAP hbmMem = nullptr;

    if (!hdcMem) {
        hdcMem = CreateCompatibleDC(hdc);
        hbmMem = CreateCompatibleBitmap(hdc, WINDOW_WIDTH, WINDOW_HEIGHT);
        SelectObject(hdcMem, hbmMem);
    }

    // Clear background (space)
    RECT rect = {0, 0, WINDOW_WIDTH, WINDOW_HEIGHT};
    HBRUSH hBrushBlack = CreateSolidBrush(RGB(0, 0, 20));
    FillRect(hdcMem, &rect, hBrushBlack);
    DeleteObject(hBrushBlack);

    // Draw stars
    for (const auto& star : stars) {
        SetPixel(hdcMem, star.x, star.y, RGB(star.brightness, star.brightness, star.brightness));
    }

    switch (gameState) {
        case GameState::TITLE_SCREEN: {
            // Title
            SetTextColor(hdcMem, RGB(255, 255, 255));
            SetBkMode(hdcMem, TRANSPARENT);

            HFONT hFont = CreateFont(48, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
                                     DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                     CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            HFONT hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            RECT titleRect = {0, 100, WINDOW_WIDTH, 150};
            DrawText(hdcMem, L"LUNAR LANDER", -1, &titleRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);

            // Version and copyright info
            hFont = CreateFont(16, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                              DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                              CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            SetTextColor(hdcMem, RGB(180, 180, 180));
            RECT versionRect = {0, 160, WINDOW_WIDTH, 180};
            DrawText(hdcMem, L"v" LANDER_VERSION_STRING, -1, &versionRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            RECT copyrightRect = {0, 180, WINDOW_WIDTH, 200};
            DrawText(hdcMem, L"Copyright (c) 2025 Todd Dube", -1, &copyrightRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            RECT githubRect = {0, 200, WINDOW_WIDTH, 220};
            DrawText(hdcMem, L"github.com/todddube/lander", -1, &githubRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);

            // Instructions
            SetTextColor(hdcMem, RGB(255, 255, 255));
            hFont = CreateFont(20, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                              DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                              CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            const wchar_t* instructions[] = {
                L"ARROW KEYS or WASD to control",
                L"SPACEBAR for main thruster",
                L"Land gently on the green landing pad",
                L"Watch your fuel and velocity!",
                L"",
                L"Press SPACE to start | Press H for high scores"
            };

            int y = 280;
            for (const auto* text : instructions) {
                RECT textRect = {0, y, WINDOW_WIDTH, y + 25};
                DrawText(hdcMem, text, -1, &textRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
                y += 30;
            }

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);
            break;
        }

        case GameState::PLAYING:
        case GameState::LANDING_SUCCESS:
        case GameState::CRASHED: {
            // Draw terrain with retro jagged mountain look
            HPEN hPenTerrain = CreatePen(PS_SOLID, 2, RGB(180, 180, 180));
            HPEN hOldPen = (HPEN)SelectObject(hdcMem, hPenTerrain);
            HBRUSH hBrushTerrain = CreateSolidBrush(RGB(80, 80, 80));
            HBRUSH hOldBrush = (HBRUSH)SelectObject(hdcMem, hBrushTerrain);

            // Build polygon for filled terrain
            std::vector<POINT> terrainPolygon;
            for (size_t i = 0; i < terrain.size(); i++) {
                POINT pt;
                pt.x = terrain[i].x;
                pt.y = terrain[i].y;
                terrainPolygon.push_back(pt);
            }
            // Add bottom corners to close polygon
            POINT bottomRight = {WINDOW_WIDTH, WINDOW_HEIGHT};
            POINT bottomLeft = {0, WINDOW_HEIGHT};
            terrainPolygon.push_back(bottomRight);
            terrainPolygon.push_back(bottomLeft);

            // Fill terrain
            Polygon(hdcMem, terrainPolygon.data(), static_cast<int>(terrainPolygon.size()));

            // Draw landing pad with special highlight
            for (size_t i = 0; i < terrain.size() - 1; i++) {
                if (terrain[i].isLandingPad) {
                    // Draw thick green landing pad
                    HPEN hPenPad = CreatePen(PS_SOLID, 4, RGB(0, 255, 0));
                    SelectObject(hdcMem, hPenPad);
                    MoveToEx(hdcMem, terrain[i].x, terrain[i].y, nullptr);
                    LineTo(hdcMem, terrain[i + 1].x, terrain[i + 1].y);

                    // Draw landing pad markers (vertical lines)
                    if (i == static_cast<size_t>(landingPadStart)) {
                        MoveToEx(hdcMem, terrain[i].x, terrain[i].y, nullptr);
                        LineTo(hdcMem, terrain[i].x, terrain[i].y - 10);
                    }
                    if (i == static_cast<size_t>(landingPadEnd - 1)) {
                        MoveToEx(hdcMem, terrain[i + 1].x, terrain[i + 1].y, nullptr);
                        LineTo(hdcMem, terrain[i + 1].x, terrain[i + 1].y - 10);
                    }

                    DeleteObject(hPenPad);
                    SelectObject(hdcMem, hPenTerrain);
                }
            }

            SelectObject(hdcMem, hOldBrush);
            DeleteObject(hBrushTerrain);
            SelectObject(hdcMem, hOldPen);
            DeleteObject(hPenTerrain);

            // Draw particles with enhanced rendering
            for (const auto& p : particles) {
                float alpha = static_cast<float>(p.lifetime) / p.maxLifetime;

                // Calculate faded color based on lifetime
                int r = static_cast<int>(GetRValue(p.color) * alpha);
                int g = static_cast<int>(GetGValue(p.color) * alpha);
                int b = static_cast<int>(GetBValue(p.color) * alpha);

                COLORREF fadedColor = RGB(r, g, b);

                if (p.type == 3) {
                    // Lander debris - draw as rotating line segments
                    HPEN hPenDebris = CreatePen(PS_SOLID, 2, fadedColor);
                    HPEN hOldPenDebris = (HPEN)SelectObject(hdcMem, hPenDebris);

                    // Calculate rotated endpoints
                    float cos_r = std::cos(p.rotation);
                    float sin_r = std::sin(p.rotation);

                    int x1 = static_cast<int>(p.pos.x);
                    int y1 = static_cast<int>(p.pos.y);
                    int x2 = static_cast<int>(p.pos.x + (p.endPos.x * cos_r - p.endPos.y * sin_r));
                    int y2 = static_cast<int>(p.pos.y + (p.endPos.x * sin_r + p.endPos.y * cos_r));

                    MoveToEx(hdcMem, x1, y1, nullptr);
                    LineTo(hdcMem, x2, y2);

                    SelectObject(hdcMem, hOldPenDebris);
                    DeleteObject(hPenDebris);
                } else {
                    // Regular particles (fire, smoke, debris)
                    int size = (p.type == 2) ? 2 : 1;  // Debris is larger
                    for (int dx = 0; dx < size; dx++) {
                        for (int dy = 0; dy < size; dy++) {
                            SetPixel(hdcMem, static_cast<int>(p.pos.x) + dx, static_cast<int>(p.pos.y) + dy, fadedColor);
                        }
                    }
                }
            }

            // Draw Apollo-style lunar lander (if not crashed)
            if (!lander.crashed) {
                HPEN hPenLander = CreatePen(PS_SOLID, 2, RGB(220, 220, 220));
                hOldPen = (HPEN)SelectObject(hdcMem, hPenLander);

                float cos_r = std::cos(lander.rotation);
                float sin_r = std::sin(lander.rotation);

                // Helper lambda to rotate and translate points
                auto transformPoint = [&](float x, float y) -> POINT {
                    POINT pt;
                    pt.x = static_cast<LONG>(lander.pos.x + (x * cos_r - y * sin_r));
                    pt.y = static_cast<LONG>(lander.pos.y + (x * sin_r + y * cos_r));
                    return pt;
                };

                // Draw descent stage (square body)
                POINT body[5];
                body[0] = transformPoint(-8, -4);
                body[1] = transformPoint(8, -4);
                body[2] = transformPoint(8, 4);
                body[3] = transformPoint(-8, 4);
                body[4] = body[0];
                Polyline(hdcMem, body, 5);

                // Draw ascent stage (smaller top module)
                POINT ascent[5];
                ascent[0] = transformPoint(-5, -8);
                ascent[1] = transformPoint(5, -8);
                ascent[2] = transformPoint(5, -4);
                ascent[3] = transformPoint(-5, -4);
                ascent[4] = ascent[0];
                Polyline(hdcMem, ascent, 5);

                // Draw landing legs (four legs)
                HPEN hPenLegs = CreatePen(PS_SOLID, 1, RGB(180, 180, 180));
                SelectObject(hdcMem, hPenLegs);

                // Left legs
                POINT leftLeg1Start = transformPoint(-8, 4);
                POINT leftLeg1End = transformPoint(-12, 10);
                MoveToEx(hdcMem, leftLeg1Start.x, leftLeg1Start.y, nullptr);
                LineTo(hdcMem, leftLeg1End.x, leftLeg1End.y);

                POINT leftLeg2Start = transformPoint(-4, 4);
                POINT leftLeg2End = transformPoint(-10, 10);
                MoveToEx(hdcMem, leftLeg2Start.x, leftLeg2Start.y, nullptr);
                LineTo(hdcMem, leftLeg2End.x, leftLeg2End.y);

                // Right legs
                POINT rightLeg1Start = transformPoint(4, 4);
                POINT rightLeg1End = transformPoint(10, 10);
                MoveToEx(hdcMem, rightLeg1Start.x, rightLeg1Start.y, nullptr);
                LineTo(hdcMem, rightLeg1End.x, rightLeg1End.y);

                POINT rightLeg2Start = transformPoint(8, 4);
                POINT rightLeg2End = transformPoint(12, 10);
                MoveToEx(hdcMem, rightLeg2Start.x, rightLeg2Start.y, nullptr);
                LineTo(hdcMem, rightLeg2End.x, rightLeg2End.y);

                // Draw foot pads
                MoveToEx(hdcMem, leftLeg1End.x - 2, leftLeg1End.y, nullptr);
                LineTo(hdcMem, leftLeg1End.x + 2, leftLeg1End.y);
                MoveToEx(hdcMem, rightLeg2End.x - 2, rightLeg2End.y, nullptr);
                LineTo(hdcMem, rightLeg2End.x + 2, rightLeg2End.y);

                DeleteObject(hPenLegs);
                SelectObject(hdcMem, hPenLander);

                // Draw main thruster flame
                if (lander.mainThrusterOn) {
                    HPEN hPenFlame = CreatePen(PS_SOLID, 3, RGB(255, 200, 0));
                    SelectObject(hdcMem, hPenFlame);

                    int flameLength = 12 + (rand() % 4);  // Flickering flame
                    POINT flameStart = transformPoint(0, 4);
                    POINT flameEnd = transformPoint(0, 4 + flameLength);

                    MoveToEx(hdcMem, flameStart.x, flameStart.y, nullptr);
                    LineTo(hdcMem, flameEnd.x, flameEnd.y);

                    // Draw flame spread
                    POINT flameLeft = transformPoint(-2, 4 + flameLength - 3);
                    POINT flameRight = transformPoint(2, 4 + flameLength - 3);
                    MoveToEx(hdcMem, flameStart.x, flameStart.y, nullptr);
                    LineTo(hdcMem, flameLeft.x, flameLeft.y);
                    MoveToEx(hdcMem, flameStart.x, flameStart.y, nullptr);
                    LineTo(hdcMem, flameRight.x, flameRight.y);

                    DeleteObject(hPenFlame);
                    SelectObject(hdcMem, hPenLander);
                }

                // Draw attitude control thrusters
                if (lander.leftThrusterOn) {
                    HPEN hPenRCS = CreatePen(PS_SOLID, 2, RGB(255, 255, 100));
                    SelectObject(hdcMem, hPenRCS);
                    POINT rcsStart = transformPoint(8, -6);
                    POINT rcsEnd = transformPoint(11, -6);
                    MoveToEx(hdcMem, rcsStart.x, rcsStart.y, nullptr);
                    LineTo(hdcMem, rcsEnd.x, rcsEnd.y);
                    DeleteObject(hPenRCS);
                    SelectObject(hdcMem, hPenLander);
                }
                if (lander.rightThrusterOn) {
                    HPEN hPenRCS = CreatePen(PS_SOLID, 2, RGB(255, 255, 100));
                    SelectObject(hdcMem, hPenRCS);
                    POINT rcsStart = transformPoint(-8, -6);
                    POINT rcsEnd = transformPoint(-11, -6);
                    MoveToEx(hdcMem, rcsStart.x, rcsStart.y, nullptr);
                    LineTo(hdcMem, rcsEnd.x, rcsEnd.y);
                    DeleteObject(hPenRCS);
                    SelectObject(hdcMem, hPenLander);
                }

                SelectObject(hdcMem, hOldPen);
                DeleteObject(hPenLander);
            }

            // Draw HUD
            SetTextColor(hdcMem, RGB(255, 255, 255));
            SetBkMode(hdcMem, TRANSPARENT);

            HFONT hFont = CreateFont(16, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                                     DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                     CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Courier New");
            HFONT hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            wchar_t buffer[256];
            StringCchPrintf(buffer, 256, L"Score: %d", score);
            TextOut(hdcMem, 10, 10, buffer, wcslen(buffer));

            StringCchPrintf(buffer, 256, L"Level: %d", level);
            TextOut(hdcMem, 10, 30, buffer, wcslen(buffer));

            StringCchPrintf(buffer, 256, L"Lives: %d", lives);
            TextOut(hdcMem, 10, 50, buffer, wcslen(buffer));

            StringCchPrintf(buffer, 256, L"Fuel: %.1f", lander.fuel);
            TextOut(hdcMem, 10, 70, buffer, wcslen(buffer));

            StringCchPrintf(buffer, 256, L"Velocity: %.2f", lander.vel.length());
            TextOut(hdcMem, 10, 90, buffer, wcslen(buffer));

            // Velocity indicator
            if (lander.vel.length() > SAFE_LANDING_SPEED) {
                SetTextColor(hdcMem, RGB(255, 0, 0));
                TextOut(hdcMem, 150, 90, L"TOO FAST!", 9);
                SetTextColor(hdcMem, RGB(255, 255, 255));
            }

            // State messages
            if (gameState == GameState::LANDING_SUCCESS) {
                HFONT hBigFont = CreateFont(36, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
                                           DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                           CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
                SelectObject(hdcMem, hBigFont);
                SetTextColor(hdcMem, RGB(0, 255, 0));

                RECT msgRect = {0, WINDOW_HEIGHT / 2 - 50, WINDOW_WIDTH, WINDOW_HEIGHT / 2 + 50};
                DrawText(hdcMem, L"LANDING SUCCESSFUL!", -1, &msgRect,
                        DT_CENTER | DT_VCENTER | DT_SINGLELINE);

                SelectObject(hdcMem, hFont);
                DeleteObject(hBigFont);
                SetTextColor(hdcMem, RGB(255, 255, 255));
            } else if (gameState == GameState::CRASHED) {
                HFONT hBigFont = CreateFont(36, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
                                           DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                           CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
                SelectObject(hdcMem, hBigFont);
                SetTextColor(hdcMem, RGB(255, 0, 0));

                RECT msgRect = {0, WINDOW_HEIGHT / 2 - 50, WINDOW_WIDTH, WINDOW_HEIGHT / 2 + 50};
                DrawText(hdcMem, L"CRASHED!", -1, &msgRect,
                        DT_CENTER | DT_VCENTER | DT_SINGLELINE);

                SelectObject(hdcMem, hFont);
                DeleteObject(hBigFont);
                SetTextColor(hdcMem, RGB(255, 255, 255));
            }

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);
            break;
        }

        case GameState::GAME_OVER: {
            SetTextColor(hdcMem, RGB(255, 255, 255));
            SetBkMode(hdcMem, TRANSPARENT);

            HFONT hFont = CreateFont(48, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
                                     DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                     CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            HFONT hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            RECT titleRect = {0, 150, WINDOW_WIDTH, 200};
            DrawText(hdcMem, L"GAME OVER", -1, &titleRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);

            hFont = CreateFont(24, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                              DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                              CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            wchar_t buffer[128];
            StringCchPrintf(buffer, 128, L"Final Score: %d", score);
            RECT scoreRect = {0, 250, WINDOW_WIDTH, 280};
            DrawText(hdcMem, buffer, -1, &scoreRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            StringCchPrintf(buffer, 128, L"Level Reached: %d", level);
            RECT levelRect = {0, 290, WINDOW_WIDTH, 320};
            DrawText(hdcMem, buffer, -1, &levelRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            RECT instructRect = {0, 380, WINDOW_WIDTH, 410};
            DrawText(hdcMem, L"Press SPACE to play again", -1, &instructRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);
            break;
        }

        case GameState::ENTER_NAME: {
            SetTextColor(hdcMem, RGB(255, 255, 255));
            SetBkMode(hdcMem, TRANSPARENT);

            HFONT hFont = CreateFont(36, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
                                     DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                     CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            HFONT hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            RECT titleRect = {0, 150, WINDOW_WIDTH, 200};
            DrawText(hdcMem, L"HIGH SCORE!", -1, &titleRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);

            hFont = CreateFont(20, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                              DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                              CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            RECT promptRect = {0, 250, WINDOW_WIDTH, 280};
            DrawText(hdcMem, L"Enter your name:", -1, &promptRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            // Draw name input box with dark background
            RECT nameRect = {WINDOW_WIDTH / 2 - 100, 300, WINDOW_WIDTH / 2 + 100, 340};

            // Fill background with dark color
            HBRUSH hBrushInput = CreateSolidBrush(RGB(20, 20, 40));
            FillRect(hdcMem, &nameRect, hBrushInput);
            DeleteObject(hBrushInput);

            // Draw border
            HPEN hPenBorder = CreatePen(PS_SOLID, 2, RGB(0, 255, 0));
            HPEN hOldPen = (HPEN)SelectObject(hdcMem, hPenBorder);
            SelectObject(hdcMem, GetStockObject(NULL_BRUSH));
            Rectangle(hdcMem, nameRect.left, nameRect.top, nameRect.right, nameRect.bottom);
            SelectObject(hdcMem, hOldPen);
            DeleteObject(hPenBorder);

            // Draw text in bright green
            SetTextColor(hdcMem, RGB(0, 255, 0));
            DrawText(hdcMem, playerName, -1, &nameRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            // Draw cursor blink
            static int cursorBlink = 0;
            cursorBlink = (cursorBlink + 1) % 60;
            if (cursorBlink < 30 && nameLength < 20) {
                SIZE textSize;
                HDC hdcTemp = GetDC(nullptr);
                SelectObject(hdcTemp, hFont);
                GetTextExtentPoint32(hdcTemp, playerName, nameLength, &textSize);
                ReleaseDC(nullptr, hdcTemp);

                int cursorX = (WINDOW_WIDTH / 2) + (textSize.cx / 2) + 2;
                MoveToEx(hdcMem, cursorX, nameRect.top + 10, nullptr);
                LineTo(hdcMem, cursorX, nameRect.bottom - 10);
            }

            SetTextColor(hdcMem, RGB(255, 255, 255));
            RECT instructRect = {0, 380, WINDOW_WIDTH, 410};
            DrawText(hdcMem, L"Press ENTER when done", -1, &instructRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);
            break;
        }

        case GameState::HIGH_SCORES: {
            SetTextColor(hdcMem, RGB(255, 255, 255));
            SetBkMode(hdcMem, TRANSPARENT);

            HFONT hFont = CreateFont(36, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
                                     DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                     CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Arial");
            HFONT hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            RECT titleRect = {0, 50, WINDOW_WIDTH, 100};
            DrawText(hdcMem, L"HIGH SCORES", -1, &titleRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);

            hFont = CreateFont(20, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                              DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                              CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Courier New");
            hOldFont = (HFONT)SelectObject(hdcMem, hFont);

            int y = 130;
            wchar_t buffer[256];
            for (int i = 0; i < MAX_HIGH_SCORES; i++) {
                if (highScores[i].score > 0) {
                    StringCchPrintf(buffer, 256, L"%2d. %-20s %6d  Lvl %2d",
                                   i + 1, highScores[i].name, highScores[i].score, highScores[i].level);
                    TextOut(hdcMem, 100, y, buffer, wcslen(buffer));
                } else {
                    StringCchPrintf(buffer, 256, L"%2d. ---", i + 1);
                    TextOut(hdcMem, 100, y, buffer, wcslen(buffer));
                }
                y += 35;
            }

            RECT instructRect = {0, 520, WINDOW_WIDTH, 550};
            DrawText(hdcMem, L"Press ESC to return", -1, &instructRect,
                    DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            SelectObject(hdcMem, hOldFont);
            DeleteObject(hFont);
            break;
        }

        default:
            break;
    }

    // Copy back buffer to screen
    BitBlt(hdc, 0, 0, WINDOW_WIDTH, WINDOW_HEIGHT, hdcMem, 0, 0, SRCCOPY);
}

// ============================================================================
// High Score Functions
// ============================================================================

/**
 * @brief Check if score qualifies for high score list
 */
bool IsHighScore(int newScore) {
    if (highScores.empty()) return true;
    return newScore > highScores[MAX_HIGH_SCORES - 1].score;
}

/**
 * @brief Update high score list with new score
 */
void UpdateHighScores(int newScore, int newLevel) {
    HighScore newEntry;
    newEntry.score = newScore;
    newEntry.level = newLevel;
    StringCchCopy(newEntry.name, 32, playerName);

    // Insert into sorted position
    bool inserted = false;
    for (int i = 0; i < MAX_HIGH_SCORES; i++) {
        if (newScore > highScores[i].score) {
            // Shift down
            for (int j = MAX_HIGH_SCORES - 1; j > i; j--) {
                highScores[j] = highScores[j - 1];
            }
            highScores[i] = newEntry;
            inserted = true;
            break;
        }
    }

    if (!inserted && highScores.size() < static_cast<size_t>(MAX_HIGH_SCORES)) {
        highScores.push_back(newEntry);
    }

    SaveHighScores();
}

/**
 * @brief Save high scores to file
 */
void SaveHighScores() {
    std::ofstream file(HIGH_SCORE_FILE, std::ios::binary);
    if (file.is_open()) {
        for (const auto& score : highScores) {
            file.write(reinterpret_cast<const char*>(&score), sizeof(HighScore));
        }
        file.close();
    }
}

/**
 * @brief Load high scores from file
 */
void LoadHighScores() {
    std::ifstream file(HIGH_SCORE_FILE, std::ios::binary);
    if (file.is_open()) {
        highScores.clear();
        HighScore score;
        while (file.read(reinterpret_cast<char*>(&score), sizeof(HighScore))) {
            highScores.push_back(score);
        }
        file.close();
    }

    // Fill remaining slots with empty scores
    while (highScores.size() < static_cast<size_t>(MAX_HIGH_SCORES)) {
        HighScore emptyScore;
        highScores.push_back(emptyScore);
    }
}

// ============================================================================
// Sound Functions
// ============================================================================

/**
 * @brief Generate realistic rocket engine sound buffer
 * Creates powerful rocket thrust with deep bass rumble and white noise
 */
void GenerateRocketSound(short* buffer, int samples) {
    static float filterState = 0.0f;
    static float deepFilterState = 0.0f;
    const float filterAlpha = 0.15f;      // Low-pass filter
    const float deepFilterAlpha = 0.05f;   // Extra deep bass filter

    for (int i = 0; i < samples; i++) {
        // Generate white noise
        float noise = static_cast<float>(rand() - RAND_MAX / 2) / (RAND_MAX / 2);

        // Apply two stages of low-pass filtering for deeper rumble
        filterState = filterState * (1.0f - filterAlpha) + noise * filterAlpha;
        deepFilterState = deepFilterState * (1.0f - deepFilterAlpha) + filterState * deepFilterAlpha;

        // Add deep bass rumble (sub-bass frequency ~30-50 Hz)
        float bassPhase = static_cast<float>(i) * 40.0f / 22050.0f;
        float deepBass = std::sin(bassPhase * 6.28318f) * 0.4f;

        // Add mid-frequency engine roar
        float midPhase = static_cast<float>(i) * 120.0f / 22050.0f;
        float midRoar = std::sin(midPhase * 6.28318f) * 0.2f;

        // Combine all elements for powerful rocket sound
        // 50% deep filtered noise, 30% sub-bass, 20% mid roar
        float sample = (deepFilterState * 0.5f + deepBass + midRoar) * 32000.0f;

        // Clamp to 16-bit range
        if (sample > 32767.0f) sample = 32767.0f;
        if (sample < -32768.0f) sample = -32768.0f;

        buffer[i] = static_cast<short>(sample);
    }
}

/**
 * @brief Initialize audio system
 */
bool InitAudio() {
    if (soundInitialized) return true;

    WAVEFORMATEX wfx = {};
    wfx.wFormatTag = WAVE_FORMAT_PCM;
    wfx.nChannels = 1;
    wfx.nSamplesPerSec = 22050;
    wfx.wBitsPerSample = 16;
    wfx.nBlockAlign = wfx.nChannels * wfx.wBitsPerSample / 8;
    wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;

    if (waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL) != MMSYSERR_NOERROR) {
        return false;
    }

    soundInitialized = true;
    return true;
}

/**
 * @brief Clean up audio system
 */
void CleanupAudio() {
    if (hWaveOut) {
        waveOutReset(hWaveOut);
        waveOutClose(hWaveOut);
        hWaveOut = nullptr;
    }
    soundInitialized = false;
}

/**
 * @brief Thread function for continuous thrust sound
 */
DWORD WINAPI ThrustSoundThreadProc(LPVOID lpParam) {
    (void)lpParam;

    if (!InitAudio()) {
        return 1;
    }

    const int bufferSize = 4410;  // 0.2 seconds at 22050 Hz
    short* buffer1 = new short[bufferSize];
    short* buffer2 = new short[bufferSize];

    // Initialize headers
    ZeroMemory(&waveHeader[0], sizeof(WAVEHDR));
    ZeroMemory(&waveHeader[1], sizeof(WAVEHDR));

    waveHeader[0].lpData = reinterpret_cast<LPSTR>(buffer1);
    waveHeader[0].dwBufferLength = bufferSize * sizeof(short);
    waveHeader[1].lpData = reinterpret_cast<LPSTR>(buffer2);
    waveHeader[1].dwBufferLength = bufferSize * sizeof(short);

    // Generate initial sound data for both buffers
    GenerateRocketSound(buffer1, bufferSize);
    GenerateRocketSound(buffer2, bufferSize);

    // Prepare and queue both buffers
    waveOutPrepareHeader(hWaveOut, &waveHeader[0], sizeof(WAVEHDR));
    waveOutPrepareHeader(hWaveOut, &waveHeader[1], sizeof(WAVEHDR));
    waveOutWrite(hWaveOut, &waveHeader[0], sizeof(WAVEHDR));
    waveOutWrite(hWaveOut, &waveHeader[1], sizeof(WAVEHDR));

    int currentBuffer = 0;

    while (thrustSoundActive) {
        WAVEHDR* pHdr = &waveHeader[currentBuffer];

        // Wait for current buffer to finish playing
        while (!(pHdr->dwFlags & WHDR_DONE) && thrustSoundActive) {
            Sleep(10);
        }

        if (!thrustSoundActive) break;

        // Generate new sound data
        short* buf = reinterpret_cast<short*>(pHdr->lpData);
        GenerateRocketSound(buf, bufferSize);

        // Write buffer again
        waveOutWrite(hWaveOut, pHdr, sizeof(WAVEHDR));

        currentBuffer = 1 - currentBuffer;  // Swap buffers
    }

    // Cleanup
    waveOutReset(hWaveOut);
    waveOutUnprepareHeader(hWaveOut, &waveHeader[0], sizeof(WAVEHDR));
    waveOutUnprepareHeader(hWaveOut, &waveHeader[1], sizeof(WAVEHDR));

    delete[] buffer1;
    delete[] buffer2;

    return 0;
}

/**
 * @brief Start continuous thrust sound
 */
void PlaySound_Thrust() {
    if (!thrustSoundActive) {
        thrustSoundActive = true;
        thrustSoundThread = CreateThread(nullptr, 0, ThrustSoundThreadProc, nullptr, 0, nullptr);
    }
}

/**
 * @brief Stop continuous thrust sound
 */
void StopSound_Thrust() {
    if (thrustSoundActive) {
        thrustSoundActive = false;
        if (thrustSoundThread) {
            WaitForSingleObject(thrustSoundThread, 1000);
            CloseHandle(thrustSoundThread);
            thrustSoundThread = nullptr;
        }
    }
}

/**
 * @brief Generate realistic explosion sound - DEEP BOOM with massive bass
 */
void GenerateExplosionSound(short* buffer, int samples) {
    for (int i = 0; i < samples; i++) {
        float t = static_cast<float>(i) / samples;

        // Generate white noise for explosion texture
        float noise = static_cast<float>(rand() - RAND_MAX / 2) / (RAND_MAX / 2);

        // Exponential decay envelope
        float envelope = std::exp(-t * 4.0f);

        // DEEP BASS BOOM - Multiple sub-bass frequencies layered
        float deepBoom1 = std::sin(t * 3.14159f * 15.0f) * envelope * 0.8f;   // 15 Hz - ultra deep
        float deepBoom2 = std::sin(t * 3.14159f * 30.0f) * envelope * 0.6f;   // 30 Hz - deep bass
        float deepBoom3 = std::sin(t * 3.14159f * 50.0f) * envelope * 0.4f;   // 50 Hz - bass rumble

        // Initial WHUMP (concentrated in first 20%)
        float whump = 0.0f;
        if (t < 0.2f) {
            float whumpEnv = std::exp(-t * 20.0f);
            whump = std::sin(t * 3.14159f * 20.0f) * whumpEnv * 1.5f;  // Massive initial impact
        }

        // Low-frequency rumble (filtered noise for texture)
        static float filterState = 0.0f;
        filterState = filterState * 0.95f + noise * 0.05f;  // Heavy low-pass filter
        float rumble = filterState * envelope * 0.7f;

        // Mid-range explosion body (gives it substance)
        float body = std::sin(t * 3.14159f * 80.0f) * envelope * 0.3f;

        // Combine all elements for MASSIVE explosion
        float sample = (whump + deepBoom1 + deepBoom2 + deepBoom3 + rumble + body) * 32000.0f;

        // Clamp to 16-bit range
        if (sample > 32767.0f) sample = 32767.0f;
        if (sample < -32768.0f) sample = -32768.0f;

        buffer[i] = static_cast<short>(sample);
    }
}

/**
 * @brief Play crash sound effect with realistic explosion
 */
void PlaySound_Crash() {
    if (!InitAudio()) {
        Beep(100, 300);  // Fallback
        return;
    }

    const int bufferSize = 22050;  // 1 second explosion
    short* explosionBuffer = new short[bufferSize];
    GenerateExplosionSound(explosionBuffer, bufferSize);

    WAVEHDR hdr = {};
    hdr.lpData = reinterpret_cast<LPSTR>(explosionBuffer);
    hdr.dwBufferLength = bufferSize * sizeof(short);

    waveOutPrepareHeader(hWaveOut, &hdr, sizeof(WAVEHDR));
    waveOutWrite(hWaveOut, &hdr, sizeof(WAVEHDR));

    // Wait for sound to finish
    while (!(hdr.dwFlags & WHDR_DONE)) {
        Sleep(10);
    }

    waveOutUnprepareHeader(hWaveOut, &hdr, sizeof(WAVEHDR));
    delete[] explosionBuffer;
}

/**
 * @brief Play landing sound effect
 */
void PlaySound_Landing() {
    Beep(800, 100);
    Beep(600, 100);
    Beep(400, 200);
}

/**
 * @brief Play menu selection sound
 */
void PlaySound_MenuSelect() {
    Beep(440, 100);
}

/**
 * @brief Thread function for fast 3-second retro intro sound
 * Classic space game intro with lunar lander theme - FAST!
 */
DWORD WINAPI IntroSoundThreadProc(LPVOID lpParam) {
    (void)lpParam;

    // FAST 3-SECOND RETRO INTRO - Lunar Lander Theme!
    // Part 1: Dramatic space opening (0-0.85 seconds)
    Beep(196, 210);   // G3 - Deep space bass
    Beep(220, 140);   // A3
    Beep(247, 140);   // B3
    Beep(262, 280);   // C4 - Building tension
    Sleep(70);

    // Part 2: Ascending rocket launch sequence (0.85-1.6 seconds)
    Beep(294, 105);   // D4 - Faster now!
    Beep(330, 105);   // E4
    Beep(349, 105);   // F4
    Beep(392, 105);   // G4
    Beep(440, 140);   // A4 - Getting higher!
    Beep(494, 140);   // B4
    Sleep(35);

    // Part 3: Triumphant lunar arrival (1.6-3.0 seconds)
    Beep(523, 175);   // C5 - Peak!
    Sleep(35);
    Beep(523, 105);   // C5 - Echo
    Beep(440, 105);   // A4
    Beep(523, 105);   // C5
    Beep(587, 280);   // D5 - Victory!
    Sleep(70);
    Beep(523, 210);   // C5 - Final heroic note
    Beep(392, 280);   // G4 - Settling on the moon

    return 0;
}

/**
 * @brief Play fast 3-second retro intro sound in background
 */
void PlaySound_Intro() {
    // Play in background thread so it doesn't block startup
    HANDLE hThread = CreateThread(nullptr, 0, IntroSoundThreadProc, nullptr, 0, nullptr);
    if (hThread) {
        CloseHandle(hThread);  // We don't need to wait for it
    }
}

// ============================================================================
// Utility Functions
// ============================================================================

/**
 * @brief Linear interpolation
 */
float Lerp(float a, float b, float t) {
    return a + (b - a) * t;
}

/**
 * @brief Clamp value between min and max
 */
float Clamp(float value, float min, float max) {
    if (value < min) return min;
    if (value > max) return max;
    return value;
}

// ============================================================================
// Windows Message Handling
// ============================================================================

/**
 * @brief Window procedure callback
 */
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    switch (uMsg) {
        case WM_CREATE:
            LoadHighScores();
            InitStars();
            SetTimer(hwnd, 1, TARGET_FRAME_TIME, nullptr);
            PlaySound_Intro();  // Play funny intro sound on startup
            return 0;

        case WM_DESTROY:
            StopSound_Thrust();  // Clean up sound thread
            CleanupAudio();      // Clean up audio system
            SaveHighScores();
            PostQuitMessage(0);
            return 0;

        case WM_TIMER:
            if (gameState == GameState::PLAYING ||
                gameState == GameState::LANDING_SUCCESS ||
                gameState == GameState::CRASHED) {
                UpdateGame();
            }
            InvalidateRect(hwnd, nullptr, FALSE);
            return 0;

        case WM_PAINT: {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hwnd, &ps);
            RenderGame(hdc);
            EndPaint(hwnd, &ps);
            return 0;
        }

        case WM_KEYDOWN:
            keys[wParam] = true;

            // Handle game state transitions
            switch (gameState) {
                case GameState::TITLE_SCREEN:
                    if (wParam == VK_SPACE) {
                        InitGame();
                        PlaySound_MenuSelect();
                    } else if (wParam == 'H') {
                        gameState = GameState::HIGH_SCORES;
                        PlaySound_MenuSelect();
                    }
                    break;

                case GameState::GAME_OVER:
                    if (wParam == VK_SPACE) {
                        InitGame();
                        PlaySound_MenuSelect();
                    }
                    break;

                case GameState::HIGH_SCORES:
                    if (wParam == VK_ESCAPE) {
                        gameState = GameState::TITLE_SCREEN;
                        PlaySound_MenuSelect();
                    }
                    break;

                case GameState::ENTER_NAME:
                    if (wParam == VK_RETURN && nameLength > 0) {
                        UpdateHighScores(score, level);
                        gameState = GameState::HIGH_SCORES;
                        PlaySound_MenuSelect();
                    } else if (wParam == VK_BACK && nameLength > 0) {
                        nameLength--;
                        playerName[nameLength] = L'\0';
                    }
                    break;

                case GameState::PLAYING:
                    if (wParam == VK_ESCAPE) {
                        gameState = GameState::TITLE_SCREEN;
                    } else if (wParam == 'P') {
                        gameState = GameState::PAUSED;
                    }
                    break;

                case GameState::PAUSED:
                    if (wParam == 'P' || wParam == VK_ESCAPE) {
                        gameState = GameState::PLAYING;
                    }
                    break;

                default:
                    break;
            }
            return 0;

        case WM_KEYUP:
            keys[wParam] = false;
            return 0;

        case WM_CHAR:
            if (gameState == GameState::ENTER_NAME) {
                if (wParam >= 32 && wParam < 127 && nameLength < 20) {
                    playerName[nameLength++] = static_cast<wchar_t>(wParam);
                    playerName[nameLength] = L'\0';
                }
            }
            return 0;

        default:
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
}

// ============================================================================
// Main Entry Point
// ============================================================================

/**
 * @brief Application entry point
 */
int WINAPI WinMain(
    _In_ HINSTANCE hInstance,
    _In_opt_ HINSTANCE hPrevInstance,
    _In_ LPSTR lpCmdLine,
    _In_ int nCmdShow
) {
    (void)hPrevInstance;
    (void)lpCmdLine;

    // Register window class
    const wchar_t CLASS_NAME[] = L"LunarLanderClass";

    WNDCLASS wc = {};
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = CLASS_NAME;
    wc.hCursor = LoadCursor(nullptr, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);

    RegisterClass(&wc);

    // Create window
    DWORD dwStyle = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX;
    RECT windowRect = {0, 0, WINDOW_WIDTH, WINDOW_HEIGHT};
    AdjustWindowRect(&windowRect, dwStyle, FALSE);

    int windowWidth = windowRect.right - windowRect.left;
    int windowHeight = windowRect.bottom - windowRect.top;

    HWND hwnd = CreateWindowEx(
        0,
        CLASS_NAME,
        L"Lunar Lander",
        dwStyle,
        CW_USEDEFAULT, CW_USEDEFAULT,
        windowWidth, windowHeight,
        nullptr,
        nullptr,
        hInstance,
        nullptr
    );

    if (hwnd == nullptr) {
        return 0;
    }

    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    // Game loop
    MSG msg = {};
    while (GetMessage(&msg, nullptr, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return static_cast<int>(msg.wParam);
}
